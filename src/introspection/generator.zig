// Model Code Generator from Introspection
// Generates complete Zig model files from introspected database schema

const std = @import("std");

const types = @import("types.zig");
const converter = @import("converter.zig");

/// Options for model generation
pub const GeneratorOptions = struct {
    /// Output directory for generated models
    output_dir: []const u8 = "src/models/generated",
    /// Generate schema definition files
    generate_schemas: bool = true,
    /// Schema output directory
    schema_output_dir: []const u8 = "schemas",
    /// Conversion options
    conversion: converter.ConversionOptions = .{},
};

/// Generate model files from introspected database
pub fn generateModels(
    allocator: std.mem.Allocator,
    db: *const types.IntrospectedDatabase,
    options: GeneratorOptions,
) !void {
    // Create output directories
    try std.fs.cwd().makePath(options.output_dir);
    if (options.generate_schemas) {
        try std.fs.cwd().makePath(options.schema_output_dir);
    }

    // Generate schema files for each table
    for (db.tables.items) |*table| {
        if (options.generate_schemas) {
            try generateSchemaFile(allocator, table, db, options);
        }
    }

    // Generate registry file
    try generateRegistryFile(allocator, db, options);

    std.debug.print("âœ… Generated {d} schema files\n", .{db.tables.items.len});
}

/// Generate a schema definition file for a table
fn generateSchemaFile(
    allocator: std.mem.Allocator,
    table: *const types.IntrospectedTable,
    db: *const types.IntrospectedDatabase,
    options: GeneratorOptions,
) !void {
    const code = try converter.generateSchemaCode(allocator, table, db, options.conversion);
    defer allocator.free(code);

    const file_name = try std.fmt.allocPrint(allocator, "{s}/{s}.zig", .{
        options.schema_output_dir,
        table.table_name,
    });
    defer allocator.free(file_name);

    const file = try std.fs.cwd().createFile(file_name, .{});
    defer file.close();

    try file.writeAll(code);

    std.debug.print("  ğŸ“„ {s}\n", .{file_name});
}

/// Generate registry.zig that imports all schemas
fn generateRegistryFile(
    allocator: std.mem.Allocator,
    db: *const types.IntrospectedDatabase,
    options: GeneratorOptions,
) !void {
    var output = std.ArrayList(u8){};
    defer output.deinit(allocator);
    const writer = output.writer(allocator);

    try writer.writeAll(
        \\// Schema Registry - Auto-generated by db pull
        \\// This file imports all schema definitions
        \\
        \\const std = @import("std");
        \\const fluentzig = @import("fluentorm");
        \\const TableSchema = fluentzig.TableSchema;
        \\
        \\// Schema imports
        \\
    );

    // Import all schemas
    for (db.tables.items) |table| {
        try writer.print("const {s}_schema = @import(\"{s}.zig\");\n", .{
            table.table_name,
            table.table_name,
        });
    }

    try writer.writeAll(
        \\
        \\/// All schema builders
        \\pub const schemas = [_]fluentzig.SchemaBuilder{
        \\
    );

    for (db.tables.items) |table| {
        try writer.print("    .{{ .name = \"{s}\", .builder_fn = {s}_schema.define }},\n", .{
            table.table_name,
            table.table_name,
        });
    }

    try writer.writeAll(
        \\};
        \\
        \\/// Get all table names
        \\pub fn getTableNames() []const []const u8 {
        \\    comptime {
        \\        var names: [schemas.len][]const u8 = undefined;
        \\        for (schemas, 0..) |s, i| {
        \\            names[i] = s.name;
        \\        }
        \\        return &names;
        \\    }
        \\}
        \\
    );

    const file_name = try std.fmt.allocPrint(allocator, "{s}/registry.zig", .{
        options.schema_output_dir,
    });
    defer allocator.free(file_name);

    const file = try std.fs.cwd().createFile(file_name, .{});
    defer file.close();

    try file.writeAll(output.items);

    std.debug.print("  ğŸ“„ {s}\n", .{file_name});
}

/// Generate a summary report of the introspection
pub fn generateReport(
    allocator: std.mem.Allocator,
    db: *const types.IntrospectedDatabase,
) ![]const u8 {
    var output = std.ArrayList(u8){};
    errdefer output.deinit(allocator);
    const writer = output.writer(allocator);

    try writer.writeAll("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n");
    try writer.writeAll("â•‘             Database Introspection Report                     â•‘\n");
    try writer.writeAll("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\n");
    try writer.print("â•‘ Tables found: {d:<46} â•‘\n", .{db.tables.items.len});
    try writer.writeAll("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n");

    for (db.tables.items) |table| {
        try writer.print("â”Œâ”€ Table: {s}\n", .{table.table_name});
        try writer.print("â”‚  Columns: {d}\n", .{table.columns.items.len});
        try writer.print("â”‚  Indexes: {d}\n", .{table.indexes.items.len});
        try writer.print("â”‚  Foreign Keys: {d}\n", .{table.foreign_keys.items.len});

        if (table.primary_key) |pk| {
            try writer.print("â”‚  Primary Key: ", .{});
            for (pk.columns.items, 0..) |col, i| {
                if (i > 0) try writer.writeAll(", ");
                try writer.print("{s}", .{col});
            }
            try writer.writeAll("\n");
        }

        try writer.writeAll("â”‚\n");
        try writer.writeAll("â”‚  Columns:\n");
        for (table.columns.items) |col| {
            const nullable_str = if (col.is_nullable) "NULL" else "NOT NULL";
            const pk_str = if (table.isPrimaryKeyColumn(col.name)) " PK" else "";
            const unique_str = if (table.isUniqueColumn(col.name) and !table.isPrimaryKeyColumn(col.name)) " UNIQUE" else "";
            try writer.print("â”‚    - {s}: {s} {s}{s}{s}\n", .{
                col.name,
                col.udt_name,
                nullable_str,
                pk_str,
                unique_str,
            });
        }

        if (table.foreign_keys.items.len > 0) {
            try writer.writeAll("â”‚\n");
            try writer.writeAll("â”‚  Foreign Keys:\n");
            for (table.foreign_keys.items) |fk| {
                try writer.print("â”‚    - {s} -> {s}.{s}\n", .{
                    fk.column_name,
                    fk.foreign_table_name,
                    fk.foreign_column_name,
                });
            }
        }

        try writer.writeAll("â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n");
    }

    return output.toOwnedSlice(allocator);
}

const std = @import("std");

const Field = @import("schema.zig").Field;
const FieldType = @import("schema.zig").FieldType;
const HasManyRelationship = @import("schema.zig").HasManyRelationship;
const model = @import("model_gen/model.zig");
const query = @import("model_gen/query.zig");
const utils = @import("model_gen/utils.zig");
const Relationship = @import("schema.zig").Relationship;
const TableSchema = @import("table.zig").TableSchema;

pub fn generateModel(allocator: std.mem.Allocator, schema: TableSchema, schema_file: []const u8, output_dir: []const u8) !void {
    const struct_name = try utils.toPascalCaseNonSingular(allocator, schema.name);
    defer allocator.free(struct_name);

    const snake_case_name = try utils.toLowerSnakeCase(allocator, schema.name);
    defer allocator.free(snake_case_name);

    // Create sub-directory: src/models/generated/{table_name}/
    const model_dir = try std.fmt.allocPrint(allocator, "{s}/{s}", .{ output_dir, snake_case_name });
    defer allocator.free(model_dir);

    std.fs.cwd().makePath(model_dir) catch |err| {
        if (err != error.PathAlreadyExists) {
            std.debug.print("Error creating directory '{s}': {}\n", .{ model_dir, err });
            return err;
        }
    };

    // Generate model declarations and logic (model.zig)
    try generateModelFile(allocator, schema, struct_name, schema_file, model_dir);

    // Generate query builder extensions (query.zig)
    try generateQueryFile(allocator, schema, schema_file, model_dir);
}

pub fn generateRegistryFile(allocator: std.mem.Allocator, schemas: []const TableSchema, output_dir: []const u8) !void {
    const file_name = try std.fmt.allocPrint(allocator, "{s}/registry.zig", .{output_dir});
    defer allocator.free(file_name);

    var output = std.ArrayList(u8){};
    defer output.deinit(allocator);
    const writer = output.writer(allocator);

    try writer.writeAll("// AUTO-GENERATED CODE - DO NOT EDIT\n");
    try writer.writeAll("// Generated by scripts/generate_model.zig\n\n");

    try writer.writeAll(
        \\const std = @import("std");
        \\const pg = @import("pg");
        \\
    );

    // Import all models
    for (schemas) |schema| {
        const struct_name = try utils.toPascalCaseNonSingular(allocator, schema.name);
        defer allocator.free(struct_name);
        const snake_case_name = try utils.toLowerSnakeCase(allocator, schema.name);
        defer allocator.free(snake_case_name);

        try writer.print("pub const {s} = @import(\"{s}/model.zig\");\n", .{ struct_name, snake_case_name });
    }

    try writer.writeAll("\n");

    // Generate Client struct
    try writer.writeAll(
        \\pub const Client = struct {
        \\    // Stateless client: simply acts as a namespace for models.
        \\    // This allows access like: Client.Users.findById(db, ...)
        \\    // which supports both pool and transaction based execution.
        \\
    );
    for (schemas) |schema| {
        const struct_name = try utils.toPascalCaseNonSingular(allocator, schema.name);
        defer allocator.free(struct_name);
        const snake_case_name = try utils.toLowerSnakeCase(allocator, schema.name);
        defer allocator.free(snake_case_name);

        try writer.print("    pub const {s} = @import(\"{s}/model.zig\");\n", .{ struct_name, snake_case_name });
    }

    // Add Rel namespace for relation types
    try writer.writeAll("\n    // Relation types for eager loading (use with fetchAs)\n");
    try writer.writeAll("    pub const Rel = struct {\n");
    for (schemas) |schema| {
        const struct_name = try utils.toPascalCaseNonSingular(allocator, schema.name);
        defer allocator.free(struct_name);
        const snake_case_name = try utils.toLowerSnakeCase(allocator, schema.name);
        defer allocator.free(snake_case_name);
        try writer.print("        pub const {s} = @import(\"{s}/rel.zig\");\n", .{ struct_name, snake_case_name });
    }
    try writer.writeAll("    };\n");

    try writer.writeAll("};\n\n");

    // Generate Tables enum
    try writer.writeAll("pub const Tables = enum {\n");
    for (schemas) |schema| {
        try writer.print("    {s},\n", .{schema.name});
    }
    try writer.writeAll("};\n\n");

    // Generate TableFields struct
    try writer.writeAll("pub const TableFields = struct {\n");
    for (schemas) |schema| {
        const struct_name = try utils.toPascalCaseNonSingular(allocator, schema.name);
        defer allocator.free(struct_name);
        try writer.print("    {s}: {s}.FieldEnum,\n", .{ schema.name, struct_name });
    }
    try writer.writeAll("};\n\n");

    // Generate TableFieldsUnion
    try writer.writeAll("pub const TableFieldsUnion = union(Tables) {\n");
    for (schemas) |schema| {
        const struct_name = try utils.toPascalCaseNonSingular(allocator, schema.name);
        defer allocator.free(struct_name);
        try writer.print("    {s}: {s}.FieldEnum,\n", .{ schema.name, struct_name });
    }
    try writer.writeAll(
        \\
        \\    pub fn toString(self: @This()) []const u8 {
        \\        return switch (self) {
    );
    for (schemas) |schema| {
        try writer.print("            .{s} => |f| @tagName(f),\n", .{schema.name});
    }
    try writer.writeAll(
        \\        };
        \\    }
        \\};
    );

    try std.fs.cwd().writeFile(.{ .sub_path = file_name, .data = output.items });

    // Let's create `root.zig` that re-exports everything from registry.zig
    const root_file_name = try std.fmt.allocPrint(allocator, "{s}/root.zig", .{output_dir});
    defer allocator.free(root_file_name);

    var root_output = std.ArrayList(u8){};
    defer root_output.deinit(allocator);
    const root_writer = root_output.writer(allocator);

    try root_writer.writeAll("// AUTO-GENERATED CODE - DO NOT EDIT\n");
    try root_writer.writeAll("pub const Client = @import(\"registry.zig\").Client;\n\n");

    for (schemas) |schema| {
        const struct_name = try utils.toPascalCaseNonSingular(allocator, schema.name);
        defer allocator.free(struct_name);
        try root_writer.print("pub const {s} = Client.{s};\n", .{ struct_name, struct_name });
    }

    try std.fs.cwd().writeFile(.{ .sub_path = root_file_name, .data = root_output.items });

    std.debug.print("âœ… Generated: {s} & root.zig\n", .{file_name});
}

// Helper to generate the main model file
fn generateModelFile(allocator: std.mem.Allocator, schema: TableSchema, struct_name: []const u8, schema_file: []const u8, output_dir: []const u8) !void {
    const file_name = try std.fmt.allocPrint(allocator, "{s}/model.zig", .{output_dir});
    defer allocator.free(file_name);

    var output = std.ArrayList(u8){};
    defer output.deinit(allocator);
    const writer = output.writer(allocator);

    // Calculate final fields
    const final_fields = try utils.getFinalFields(allocator, schema);
    defer allocator.free(final_fields);

    // Generate header
    try model.generateHeader(writer, schema_file);

    // Generate imports
    try model.generateModelImports(writer, schema, allocator);

    // Generate struct definition (Strict)
    try model.generateStructDefinition(writer, schema, struct_name, final_fields, allocator);

    // Generate Deinit
    try model.generateDeinit(writer, final_fields, allocator);

    // Generate CreateInput
    try model.generateCreateInput(writer, final_fields, allocator);

    // Generate UpdateInput
    try model.generateUpdateInput(writer, final_fields, allocator);

    // Generate SQL methods
    const has_upsert = try model.generateSQLMethods(writer, schema, struct_name, final_fields, allocator);

    // Generate base
    try model.generateBaseModelWrapper(writer, struct_name);

    // Generate DDL wrappers
    try model.generateDDLWrappers(writer);

    // Generate CRUD wrappers
    try model.generateCRUDWrappers(writer, struct_name, has_upsert);

    // Generate JSON response helpers
    try model.generateJsonResponseHelpers(writer, struct_name, final_fields);

    // Generate relationship methods
    try model.generateRelationshipMethods(writer, schema, struct_name, allocator);

    // Write to file
    try std.fs.cwd().writeFile(.{ .sub_path = file_name, .data = output.items });

    std.debug.print("    -> Created {s}/model.zig\n", .{output_dir});

    // Generate rel.zig with explicit relation types
    try generateRelFile(allocator, schema, struct_name, final_fields, output_dir);
}

fn generateQueryFile(allocator: std.mem.Allocator, schema: TableSchema, schema_file: []const u8, output_dir: []const u8) !void {
    const file_name = try std.fmt.allocPrint(allocator, "{s}/query.zig", .{output_dir});
    defer allocator.free(file_name);

    var output = std.ArrayList(u8){};
    defer output.deinit(allocator);
    const writer = output.writer(allocator);

    try query.generateHeader(writer, schema_file);

    // Imports
    try query.generateImports(writer, schema);

    try query.generateStructDefinition(writer);

    try query.generatePubMethods(writer, schema, allocator);
    try std.fs.cwd().writeFile(.{ .sub_path = file_name, .data = output.items });
    std.debug.print("    -> Created {s}/query.zig\n", .{output_dir});
}

fn generateRelFile(allocator: std.mem.Allocator, schema: TableSchema, struct_name: []const u8, fields: []const Field, output_dir: []const u8) !void {
    const file_name = try std.fmt.allocPrint(allocator, "{s}/rel.zig", .{output_dir});
    defer allocator.free(file_name);

    var output = std.ArrayList(u8){};
    defer output.deinit(allocator);
    const writer = output.writer(allocator);

    try model.generateRelationTypes(writer, schema, struct_name, fields, allocator);

    // Only write file if there's content (has relations)
    if (output.items.len > 0) {
        try std.fs.cwd().writeFile(.{ .sub_path = file_name, .data = output.items });
        std.debug.print("    -> Created {s}/rel.zig\n", .{output_dir});
    }
}

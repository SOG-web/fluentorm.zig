const std = @import("std");

const TableSchema = @import("../table.zig").TableSchema;
const utils = @import("utils.zig");

pub fn generateHeader(writer: anytype, schema_file: []const u8) !void {
    try writer.print(
        \\// AUTO-GENERATED CODE - DO NOT EDIT
        \\// Generated by scripts/generate_model.zig
        \\// Source schema: {s}
        \\// To regenerate: zig run scripts/generate_model.zig -- {s}
        \\
        \\
    , .{ schema_file, schema_file });
}

pub fn generateImports(writer: anytype, schema: TableSchema) !void {
    var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);
    defer arena.deinit();
    const allocator = arena.allocator();

    try writer.writeAll(
        \\const std = @import("std");
        \\const pg = @import("pg");
        \\const BaseModel = @import("../base.zig").BaseModel;
        \\const Executor = @import("../executor.zig").Executor;
        \\const query = @import("../query.zig");
        \\const Operator = query.Operator;
        \\const WhereClauseType = query.WhereClauseType;
        \\const WhereClauseInternal = query.WhereClauseInternal;
        \\const InType = query.InType;
        \\const JoinType = query.JoinType;
        \\const AggregateType = query.AggregateType;
        \\const Model = @import("model.zig");
        \\const FieldEnum = Model.FieldEnum;
        \\const RelationEnum = Model.RelationEnum;
        \\const Transaction = @import("../transaction.zig").Transaction;
        \\const Relationship = @import("../base.zig").Relationship;
        \\
    );

    // Collect all related tables from both relationships and has_many_relationships
    var seen_tables = std.StringHashMap(void).init(allocator);
    defer seen_tables.deinit();

    // Add imports from regular relationships (belongsTo, hasOne, foreign)
    for (schema.relationships.items) |rel| {
        // Skip self-references (e.g., comments referencing comments for parent_id)
        if (std.mem.eql(u8, rel.references_table, schema.name)) continue;

        if (!seen_tables.contains(rel.references_table)) {
            try seen_tables.put(rel.references_table, {});
        }
    }

    // Add imports from hasMany relationships
    for (schema.has_many_relationships.items) |rel| {
        // Skip self-references (e.g., comments has many comments for replies)
        if (std.mem.eql(u8, rel.foreign_table, schema.name)) continue;

        if (!seen_tables.contains(rel.foreign_table)) {
            try seen_tables.put(rel.foreign_table, {});
        }
    }

    // Generate imports if we have any related models
    if (seen_tables.count() > 0) {
        try writer.writeAll("\n// Related models\n");

        var iter = seen_tables.keyIterator();
        while (iter.next()) |table_name| {
            // Use PascalCase non-singular for struct reference
            const struct_name = try utils.toPascalCaseNonSingular(allocator, table_name.*);
            defer allocator.free(struct_name);

            // Use snake_case for directory name
            const dir_name = try utils.toLowerSnakeCase(allocator, table_name.*);
            defer allocator.free(dir_name);

            // Import from sibling directory: @import("../users/model.zig")
            try writer.print("const {s} = @import(\"../{s}/model.zig\");\n", .{
                struct_name,
                dir_name,
            });
        }
    }

    try writer.writeAll("\n");
}

pub fn generateStructDefinition(writer: anytype) !void {
    try writer.writeAll("const Self = @This();\n\n");
    try writer.writeAll("// Fields\n");

    try writer.writeAll(
        \\ arena: std.heap.ArenaAllocator,
        \\ select_clauses: std.ArrayList([]const u8),
        \\ where_clauses: std.ArrayList(WhereClauseInternal),
        \\ order_clauses: std.ArrayList([]const u8),
        \\ group_clauses: std.ArrayList([]const u8),
        \\ having_clauses: std.ArrayList([]const u8),
        \\ join_clauses: std.ArrayList([]const u8),
        \\ limit_val: ?u64 = null,
        \\ offset_val: ?u64 = null,
        \\ include_deleted: bool = false,
        \\ distinct_enabled: bool = false,
        \\ includes_clauses: std.ArrayList(RelationEnum),
        \\
    );

    try writer.writeAll("\n");

    // clauses
    try writer.writeAll(
        \\  pub const WhereClause = struct {
        \\      field: FieldEnum,
        \\      operator: Operator,
        \\      value: ?[]const u8 = null,
        \\   };
        \\
        \\
        \\ pub const OrderByClause = struct {
        \\      field: FieldEnum,
        \\      direction: enum {
        \\         asc,
        \\         desc,
        \\      },
        \\     pub fn toSql(self: OrderByClause) []const u8 {
        \\         return switch (self.direction) {
        \\            .asc => "ASC",
        \\            .desc => "DESC",
        \\         };
        \\      }
        \\   };
        \\
        \\   pub const SelectField = []const FieldEnum;
    );

    try writer.writeAll("\n");

    // init, deinit, reset
    try writer.writeAll(
        \\ pub fn init() Self {
        \\    return Self{
        \\       .arena = std.heap.ArenaAllocator.init(std.heap.page_allocator),
        \\       .select_clauses = std.ArrayList([]const u8){},
        \\       .where_clauses = std.ArrayList(WhereClauseInternal){},
        \\       .order_clauses = std.ArrayList([]const u8){},
        \\       .group_clauses = std.ArrayList([]const u8){},
        \\       .having_clauses = std.ArrayList([]const u8){},
        \\       .join_clauses = std.ArrayList([]const u8){},
        \\       .includes_clauses = std.ArrayList(RelationEnum){},
        \\    };
        \\ }
        \\
        \\ pub fn deinit(self: *Self) void {
        \\    self.where_clauses.deinit(self.arena.allocator());
        \\    self.select_clauses.deinit(self.arena.allocator());
        \\    self.order_clauses.deinit(self.arena.allocator());
        \\    self.group_clauses.deinit(self.arena.allocator());
        \\    self.having_clauses.deinit(self.arena.allocator());
        \\    self.join_clauses.deinit(self.arena.allocator());
        \\    self.includes_clauses.deinit(self.arena.allocator());
        \\    self.arena.deinit();
        \\ }
        \\
        \\ pub fn reset(self: *Self) void {
        \\    self.select_clauses.clearAndFree(self.arena.allocator());
        \\    self.where_clauses.clearAndFree(self.arena.allocator());
        \\    self.order_clauses.clearAndFree(self.arena.allocator());
        \\    self.group_clauses.clearAndFree(self.arena.allocator());
        \\    self.having_clauses.clearAndFree(self.arena.allocator());
        \\    self.join_clauses.clearAndFree(self.arena.allocator());
        \\    self.includes_clauses.clearAndFree(self.arena.allocator());
        \\    self.limit_val = null;
        \\    self.offset_val = null;
        \\    self.include_deleted = false;
        \\    self.distinct_enabled = false;
        \\ }
    );

    try writer.writeAll("\n");
}

pub fn generatePubMethods(writer: anytype) !void {
    const query_text = @embedFile("query.txt");
    try writer.writeAll(query_text);
}

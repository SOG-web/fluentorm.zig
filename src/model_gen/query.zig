const std = @import("std");

const HasManyRelationship = @import("../schema.zig").HasManyRelationship;
const Relationship = @import("../schema.zig").Relationship;
const TableSchema = @import("../table.zig").TableSchema;
const utils = @import("utils.zig");

pub fn generateHeader(writer: anytype, schema_file: []const u8) !void {
    try writer.print(
        \\// AUTO-GENERATED CODE - DO NOT EDIT
        \\// Generated by scripts/generate_model.zig
        \\// Source schema: {s}
        \\// To regenerate: zig run scripts/generate_model.zig -- {s}
        \\
        \\
    , .{ schema_file, schema_file });
}

pub fn generateImports(writer: anytype, schema: TableSchema) !void {
    var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);
    defer arena.deinit();
    const allocator = arena.allocator();

    try writer.writeAll(
        \\const std = @import("std");
        \\const pg = @import("pg");
        \\const BaseModel = @import("../base.zig").BaseModel;
        \\const Executor = @import("../executor.zig").Executor;
        \\const query = @import("../query.zig");
        \\const JoinClause = query.JoinClause;
        \\const WhereValue = query.WhereValue;
        \\const IncludeClauseInput = Model.IncludeClauseInput;
        \\const Operator = query.Operator;
        \\const WhereClauseType = query.WhereClauseType;
        \\const WhereClauseInternal = query.WhereClauseInternal;
        \\const InType = query.InType;
        \\const JoinType = query.JoinType;
        \\const AggregateType = query.AggregateType;
        \\const Model = @import("model.zig");
        \\const FieldEnum = Model.FieldEnum;
        \\const RelationEnum = Model.RelationEnum;
        \\const Transaction = @import("../transaction.zig").Transaction;
        \\const Relationship = @import("../base.zig").Relationship;
        \\
    );

    // Collect all related tables from both relationships and has_many_relationships
    var seen_tables = std.StringHashMap(void).init(allocator);
    defer seen_tables.deinit();

    // Add imports from regular relationships (belongsTo, hasOne, foreign)
    for (schema.relationships.items) |rel| {
        // Skip self-references (e.g., comments referencing comments for parent_id)
        if (std.mem.eql(u8, rel.references_table, schema.name)) continue;

        if (!seen_tables.contains(rel.references_table)) {
            try seen_tables.put(rel.references_table, {});
        }
    }

    // Add imports from hasMany relationships
    for (schema.has_many_relationships.items) |rel| {
        // Skip self-references (e.g., comments has many comments for replies)
        if (std.mem.eql(u8, rel.foreign_table, schema.name)) continue;

        if (!seen_tables.contains(rel.foreign_table)) {
            try seen_tables.put(rel.foreign_table, {});
        }
    }

    // Generate imports if we have any related models
    if (seen_tables.count() > 0) {
        try writer.writeAll("\n// Related models\n");

        var iter = seen_tables.keyIterator();
        while (iter.next()) |table_name| {
            // Use PascalCase non-singular for struct reference
            const struct_name = try utils.toPascalCaseNonSingular(allocator, table_name.*);
            defer allocator.free(struct_name);

            // Use snake_case for directory name
            const dir_name = try utils.toLowerSnakeCase(allocator, table_name.*);
            defer allocator.free(dir_name);

            // Import from sibling directory: @import("../users/model.zig")
            try writer.print("const {s} = @import(\"../{s}/model.zig\");\n", .{
                struct_name,
                dir_name,
            });
        }
    }

    try writer.writeAll("\n");
}

pub fn generateStructDefinition(writer: anytype) !void {
    try writer.writeAll("const Self = @This();\n\n");
    try writer.writeAll("// Fields\n");

    try writer.writeAll(
        \\ arena: std.heap.ArenaAllocator,
        \\ select_clauses: std.ArrayList([]const u8),
        \\ where_clauses: std.ArrayList(WhereClauseInternal),
        \\ order_clauses: std.ArrayList([]const u8),
        \\ group_clauses: std.ArrayList([]const u8),
        \\ having_clauses: std.ArrayList([]const u8),
        \\ join_clauses: std.ArrayList(JoinClause),
        \\ limit_val: ?u64 = null,
        \\ offset_val: ?u64 = null,
        \\ include_deleted: bool = false,
        \\ distinct_enabled: bool = false,
        \\ includes_clauses: std.ArrayList(Model.IncludeClauseInput),
        \\ base_select_custom: bool = false,
        \\ select_raw: bool = false,
        \\ fill_base_select: bool = false,
        \\ owns_arena: bool = true,
        \\
    );

    try writer.writeAll("\n");

    // clauses
    try writer.writeAll(
        \\  pub const WhereClause = struct {
        \\      where_type: WhereClauseType = .@"and",
        \\      field: FieldEnum,
        \\      operator: Operator,
        \\      value: ?WhereValue = null,
        \\   };
        \\
        \\
        \\ pub const OrderByClause = struct {
        \\      field: FieldEnum,
        \\      direction: enum {
        \\         asc,
        \\         desc,
        \\      },
        \\     pub fn toSql(self: OrderByClause) []const u8 {
        \\         return switch (self.direction) {
        \\            .asc => "ASC",
        \\            .desc => "DESC",
        \\         };
        \\      }
        \\   };
        \\
        \\   pub const SelectField = []const FieldEnum;
    );

    try writer.writeAll("\n");

    // init, deinit, reset
    try writer.writeAll(
        \\ pub fn tablename(_: *Self) []const u8 {
        \\    return Model.tableName();
        \\ }
        \\
        \\ /// Create a new query builder using page_allocator for its arena.
        \\ pub fn init() Self {
        \\    return initWithAllocator(std.heap.page_allocator);
        \\ }
        \\
        \\ /// Create a query builder with a custom backing allocator for its arena.
        \\ pub fn initWithAllocator(backing_allocator: std.mem.Allocator) Self {
        \\    return Self{
        \\       .arena = std.heap.ArenaAllocator.init(backing_allocator),
        \\       .select_clauses = std.ArrayList([]const u8){},
        \\       .where_clauses = std.ArrayList(WhereClauseInternal){},
        \\       .order_clauses = std.ArrayList([]const u8){},
        \\       .group_clauses = std.ArrayList([]const u8){},
        \\       .having_clauses = std.ArrayList([]const u8){},
        \\       .join_clauses = std.ArrayList(JoinClause){},
        \\       .includes_clauses = std.ArrayList(Model.IncludeClauseInput){},
        \\       .base_select_custom = false,
        \\       .select_raw = false,
        \\       .fill_base_select = false,
        \\    };
        \\ }
        \\
        \\ /// Create a query builder using an existing ArenaAllocator.
        \\ /// Ideal for http.zig request handlers where the arena is managed externally.
        \\ pub fn initWithArena(arena_allocator: *std.heap.ArenaAllocator) Self {
        \\    return Self{
        \\       .arena = arena_allocator.*,
        \\       .owns_arena = false,
        \\       .select_clauses = std.ArrayList([]const u8){},
        \\       .where_clauses = std.ArrayList(WhereClauseInternal){},
        \\       .order_clauses = std.ArrayList([]const u8){},
        \\       .group_clauses = std.ArrayList([]const u8){},
        \\       .having_clauses = std.ArrayList([]const u8){},
        \\       .join_clauses = std.ArrayList(JoinClause){},
        \\       .includes_clauses = std.ArrayList(Model.IncludeClauseInput){},
        \\       .base_select_custom = false,
        \\       .select_raw = false,
        \\       .fill_base_select = false,
        \\    };
        \\ }
        \\
        \\ pub fn deinit(self: *Self) void {
        \\    self.where_clauses.deinit(self.arena.allocator());
        \\    self.select_clauses.deinit(self.arena.allocator());
        \\    self.order_clauses.deinit(self.arena.allocator());
        \\    self.group_clauses.deinit(self.arena.allocator());
        \\    self.having_clauses.deinit(self.arena.allocator());
        \\    self.join_clauses.deinit(self.arena.allocator());
        \\    self.includes_clauses.deinit(self.arena.allocator());
        \\    if (self.owns_arena) {
        \\        self.arena.deinit();
        \\    }
        \\ }
        \\
        \\ pub fn reset(self: *Self) void {
        \\    self.select_clauses.clearAndFree(self.arena.allocator());
        \\    self.where_clauses.clearAndFree(self.arena.allocator());
        \\    self.order_clauses.clearAndFree(self.arena.allocator());
        \\    self.group_clauses.clearAndFree(self.arena.allocator());
        \\    self.having_clauses.clearAndFree(self.arena.allocator());
        \\    self.join_clauses.clearAndFree(self.arena.allocator());
        \\    self.includes_clauses.clearAndFree(self.arena.allocator());
        \\    self.limit_val = null;
        \\    self.offset_val = null;
        \\    self.include_deleted = false;
        \\    self.distinct_enabled = false;
        \\    self.base_select_custom = false;
        \\    self.select_raw = false;
        \\    self.fill_base_select = false;
        \\ }
    );

    try writer.writeAll("\n");
}

pub fn generateBuildIncludeSql(writer: anytype, schema: TableSchema, allocator: std.mem.Allocator) !void {
    try writer.writeAll(
        \\    pub fn buildIncludeSql(self: *Self, rel: IncludeClauseInput) !JoinClause {
        \\        const rel_tag = std.meta.activeTag(rel);
        \\        const relation = Model.getRelation(rel_tag);
        \\
        \\        var clause = JoinClause{
        \\            .join_type = JoinType.left,
        \\            .join_table = relation.foreign_table,
        \\            .join_field = relation.foreign_key,
        \\            .join_operator = .eq,
        \\            .base_field = relation.local_key,
        \\            .predicates = &.{},
        \\            .select = &.{"*"},
        \\        };
        \\
        \\        switch (rel) {
    );

    const body =
        \\                // Construct the where clause from rel into an sql string
        \\                if (r.where.len > 0) {
        \\                    clause.predicates = try self.arena.allocator().alloc(query.PredicateClause, r.where.len);
        \\                    for (r.where, 0..) |cl, i| {
        \\                        const str = try query.buildIncludeWhere(self, cl, @tagName(relation.foreign_table), cl.value);
        \\                        clause.predicates[i] = .{
        \\                            .where_type = cl.where_type,
        \\                            .sql = str,
        \\                        };
        \\                    }
        \\                }
        \\
        \\                // Construct select clause
        \\                if (r.select.len > 0) {
        \\                    const selects = try self.arena.allocator().alloc([]const u8, r.select.len);
        \\                    for (r.select, 0..) |field, i| {
        \\                        selects[i] = @tagName(field);
        \\                    }
        \\                    clause.select = selects;
        \\                }
    ;

    var has_rels = false;

    for (schema.relationships.items) |rel| {
        if (std.mem.eql(u8, rel.references_table, schema.name)) continue;
        const field_name = try utils.relationshipToFieldName(allocator, rel);
        defer allocator.free(field_name);

        try writer.print("            .{s} => |r| {{\n", .{field_name});
        try writer.writeAll(body);
        try writer.writeAll("\n            },\n");
        has_rels = true;
    }

    for (schema.has_many_relationships.items) |rel| {
        if (std.mem.eql(u8, rel.foreign_table, schema.name)) continue;
        const field_name = try utils.hasManyMethodName(allocator, rel.name);
        defer allocator.free(field_name);
        var camel = try allocator.dupe(u8, field_name);
        defer allocator.free(camel);
        if (camel.len > 0) camel[0] = std.ascii.toLower(camel[0]);

        try writer.print("            .{s} => |r| {{\n", .{camel});
        try writer.writeAll(body);
        try writer.writeAll("                clause.is_many = true;\n");
        try writer.writeAll("\n            },\n");
        has_rels = true;
    }

    if (!has_rels) {
        try writer.writeAll("            else => {},\n");
    }

    try writer.writeAll(
        \\        }
        \\        return clause;
        \\    }
        \\
    );
}

pub fn generatePubMethods(writer: anytype, schema: TableSchema, allocator: std.mem.Allocator) !void {
    try generateBuildIncludeSql(writer, schema, allocator);
    const query_text = @embedFile("query.txt");
    try writer.writeAll(query_text);
}

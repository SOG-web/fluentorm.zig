const std = @import("std");

const Field = @import("../schema.zig").Field;
const FieldType = @import("../schema.zig").FieldType;
const HasManyRelationship = @import("../schema.zig").HasManyRelationship;
const Relationship = @import("../schema.zig").Relationship;
const TableSchema = @import("../table.zig").TableSchema;
const utils = @import("utils.zig");

pub fn generateHeader(writer: anytype, schema_file: []const u8) !void {
    try writer.print(
        \\// AUTO-GENERATED CODE - DO NOT EDIT
        \\// Generated by scripts/generate_model.zig
        \\// Source schema: {s}
        \\// To regenerate: zig run scripts/generate_model.zig -- {s}
        \\
        \\
    , .{ schema_file, schema_file });
}

pub fn generateModelImports(writer: anytype, schema: TableSchema, allocator: std.mem.Allocator) !void {
    try writer.writeAll(
        \\const std = @import("std");
        \\const pg = @import("pg");
        \\const BaseModel = @import("../base.zig").BaseModel;
        \\const Query = @import("query.zig");
        \\const Relationship = @import("../base.zig").Relationship;
        \\
    );

    // Collect all related tables from both relationships and has_many_relationships
    var seen_tables = std.StringHashMap(void).init(allocator);
    defer seen_tables.deinit();

    // Add imports from regular relationships (belongsTo, hasOne, foreign)
    for (schema.relationships.items) |rel| {
        // Skip self-references (e.g., comments referencing comments for parent_id)
        if (std.mem.eql(u8, rel.references_table, schema.name)) continue;

        if (!seen_tables.contains(rel.references_table)) {
            try seen_tables.put(rel.references_table, {});
        }
    }

    // Add imports from hasMany relationships
    for (schema.has_many_relationships.items) |rel| {
        // Skip self-references (e.g., comments has many comments for replies)
        if (std.mem.eql(u8, rel.foreign_table, schema.name)) continue;

        if (!seen_tables.contains(rel.foreign_table)) {
            try seen_tables.put(rel.foreign_table, {});
        }
    }

    // Generate imports if we have any related models
    if (seen_tables.count() > 0) {
        try writer.writeAll("\n// Related models\n");

        var iter = seen_tables.keyIterator();
        while (iter.next()) |table_name| {
            // Use PascalCase non-singular for struct reference
            const struct_name = try utils.toPascalCaseNonSingular(allocator, table_name.*);
            defer allocator.free(struct_name);

            // Use snake_case for directory name
            const dir_name = try utils.toLowerSnakeCase(allocator, table_name.*);
            defer allocator.free(dir_name);

            // Import from sibling directory: @import("../users/model.zig")
            try writer.print("const {s} = @import(\"../{s}/model.zig\");\n", .{
                struct_name,
                dir_name,
            });
        }
    }

    try writer.writeAll("\n");
}

pub fn generateStructDefinition(writer: anytype, schema: TableSchema, struct_name: []const u8, fields: []const Field, allocator: std.mem.Allocator) !void {
    try writer.print("const {s} = @This();\n\n", .{struct_name});
    try writer.writeAll("// Fields\n");

    for (fields) |field| {
        try writer.print("    {s}: {s},\n", .{ field.name, field.type.toZigType() });
    }

    try writer.writeAll("\n    // Relationships (for eager loading)\n");

    // hasOne / belongsTo
    for (schema.relationships.items) |rel| {
        if (std.mem.eql(u8, rel.references_table, schema.name)) continue;
        const field_name = try utils.relationshipToFieldName(allocator, rel);
        defer allocator.free(field_name);
        const type_name = try utils.toPascalCaseNonSingular(allocator, rel.references_table);
        defer allocator.free(type_name);

        try writer.print("    {s}: ?{s}.{s}Partial = null,\n", .{ field_name, type_name, type_name });
    }

    // hasMany
    for (schema.has_many_relationships.items) |rel| {
        if (std.mem.eql(u8, rel.foreign_table, schema.name)) continue;
        const field_name = try utils.hasManyMethodName(allocator, rel.name); // Using relation name (key) in config
        defer allocator.free(field_name);

        // Convert field_name from PascalCase to camelCase (e.g. Posts -> posts)
        var camel_field = try allocator.dupe(u8, field_name);
        defer allocator.free(camel_field);
        if (camel_field.len > 0) camel_field[0] = std.ascii.toLower(camel_field[0]);

        const type_name = try utils.toPascalCaseNonSingular(allocator, rel.foreign_table);
        defer allocator.free(type_name);

        try writer.print("    {s}: ?[]const {s}.{s}Partial = null,\n", .{ camel_field, type_name, type_name });
    }

    // generate field enum
    try writer.writeAll("    pub const FieldEnum = enum {\n");
    for (fields) |field| {
        try writer.print("        {s},\n", .{field.name});
    }
    try writer.writeAll("    };\n");

    // Generate toPartial method
    try writer.print("    pub fn toPartial(self: @This()) !{s}Partial {{\n", .{struct_name});
    try writer.print("        return {s}Partial{{\n", .{struct_name});
    for (fields) |field| {
        try writer.print("            .{s} = self.{s},\n", .{ field.name, field.name });
    }
    try writer.writeAll("        };\n");
    try writer.writeAll("    }\n\n");

    try writer.writeAll("    pub const RelationEnum = enum {\n");

    // Add enum members
    for (schema.relationships.items) |rel| {
        if (std.mem.eql(u8, rel.references_table, schema.name)) continue;
        const field_name = try utils.relationshipToFieldName(allocator, rel);
        defer allocator.free(field_name);
        try writer.print("        {s},\n", .{field_name});
    }
    for (schema.has_many_relationships.items) |rel| {
        if (std.mem.eql(u8, rel.foreign_table, schema.name)) continue;
        const field_name = try utils.hasManyMethodName(allocator, rel.name);
        defer allocator.free(field_name);
        // camelCase conversion
        var camel = try allocator.dupe(u8, field_name);
        defer allocator.free(camel);
        if (camel.len > 0) camel[0] = std.ascii.toLower(camel[0]);

        try writer.print("        {s},\n", .{camel});
    }
    try writer.writeAll("    };\n\n");

    // Generate metadata lookup
    try writer.writeAll("    pub fn getRelation(rel: RelationEnum) Relationship {\n");
    try writer.writeAll("        return switch (rel) {\n");

    for (schema.relationships.items) |rel| {
        if (std.mem.eql(u8, rel.references_table, schema.name)) continue;
        const field_name = try utils.relationshipToFieldName(allocator, rel);
        defer allocator.free(field_name);

        // "foo" => .{ .name = "foo", .type = .belongsTo, ... }
        try writer.print("            .{s} => .{{ .name = \"{s}\", .type = .belongsTo, .foreign_table = \"{s}\", .foreign_key = \"{s}\", .local_key = \"{s}\" }},\n", .{ field_name, field_name, rel.references_table, "id", rel.column });
        // Note: belongsTo means WE have the foreign key (rel.column) pointing to THEIR "id".
        // For include(), we collect OUR (local) key and query THEIR table where (foreign) key IN (...).
        // BUT wait.
        // belongsTo: Post.user_id -> User.id.
        // Post.include(.user):
        //   Collect post.user_id.
        //   Query User where id IN (userIds).
        // So foreign_table = "users", foreign_key = "id", local_key = "user_id".
    }

    for (schema.has_many_relationships.items) |rel| {
        if (std.mem.eql(u8, rel.foreign_table, schema.name)) continue;
        const field_name = try utils.hasManyMethodName(allocator, rel.name);
        defer allocator.free(field_name);
        var camel = try allocator.dupe(u8, field_name);
        defer allocator.free(camel);
        if (camel.len > 0) camel[0] = std.ascii.toLower(camel[0]);

        // hasMany: User.id -> Post.user_id
        // User.include(.posts):
        //   Collect user.id.
        //   Query Post where user_id IN (userIds).
        // foreign_table = "posts" (rel.foreign_table), foreign_key = "user_id" (rel.foreign_column), local_key = "id".

        try writer.print("            .{s} => .{{ .name = \"{s}\", .type = .hasMany, .foreign_table = \"{s}\", .foreign_key = \"{s}\", .local_key = \"{s}\" }},\n", .{ camel, camel, rel.foreign_table, rel.foreign_column, rel.local_column });
    }

    try writer.writeAll("        };\n");
    try writer.writeAll("    }\n\n");

    try writer.writeAll("    pub const IncludeClauseInput = union(RelationEnum) {\n");

    for (schema.relationships.items) |rel| {
        if (std.mem.eql(u8, rel.references_table, schema.name)) continue;
        const field_name = try utils.relationshipToFieldName(allocator, rel);
        defer allocator.free(field_name);
        const type_name = try utils.toPascalCaseNonSingular(allocator, rel.references_table);
        defer allocator.free(type_name);

        try writer.print("        {s}: {s}.IncludeClauseInput,\n", .{ field_name, type_name });
    }

    for (schema.has_many_relationships.items) |rel| {
        if (std.mem.eql(u8, rel.foreign_table, schema.name)) continue;
        const field_name = try utils.hasManyMethodName(allocator, rel.name);
        defer allocator.free(field_name);
        var camel = try allocator.dupe(u8, field_name);
        defer allocator.free(camel);
        if (camel.len > 0) camel[0] = std.ascii.toLower(camel[0]);

        const type_name = try utils.toPascalCaseNonSingular(allocator, rel.foreign_table);
        defer allocator.free(type_name);

        try writer.print("        {s}: {s}.IncludeClauseInput,\n", .{ camel, type_name });
    }
    try writer.writeAll("    };\n\n");
}

pub fn generateDeinit(writer: anytype, fields: []const Field, allocator: std.mem.Allocator) !void {
    _ = allocator;
    try writer.writeAll("    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {\n");

    for (fields) |field| {
        const zig_type = field.type.toZigType();
        if (std.mem.eql(u8, zig_type, "[]const u8") or std.mem.eql(u8, zig_type, "?[]const u8")) {
            if (field.type.isOptional()) {
                try writer.print("        if (self.{s}) |v| allocator.free(v);\n", .{field.name});
            } else {
                try writer.print("        allocator.free(self.{s});\n", .{field.name});
            }
        }
    }

    try writer.writeAll("    }\n\n");
}

pub fn generatePartialStruct(writer: anytype, struct_name: []const u8, fields: []const Field) !void {
    try writer.print("pub const {s}Partial = struct {{\n", .{struct_name});
    for (fields) |field| {
        // All fields are optional and default to null in the partial struct
        const zig_type = field.type.toZigType();
        // If type is already optional, use it as is but still init to null
        if (field.type.isOptional()) {
            try writer.print("    {s}: {s} = null,\n", .{ field.name, zig_type });
        } else {
            try writer.print("    {s}: ?{s} = null,\n", .{ field.name, zig_type });
        }
    }
    try writer.writeAll("};\n\n");
}

pub fn generateCreateInput(writer: anytype, fields: []const Field, allocator: std.mem.Allocator) !void {
    _ = allocator;
    try writer.writeAll("    // Input type for creating new records\n");
    try writer.writeAll("    pub const CreateInput = struct {\n");

    for (fields) |field| {
        if (field.create_input == .required) {
            try writer.print("        {s}: {s},\n", .{ field.name, field.type.toZigType() });
        } else if (field.create_input == .optional) {
            const zig_type = field.type.toZigType();
            if (field.type.isOptional()) {
                try writer.print("        {s}: {s} = null,\n", .{ field.name, zig_type });
            } else {
                try writer.print("        {s}: ?{s} = null,\n", .{ field.name, zig_type });
            }
        }
    }

    try writer.writeAll("    };\n\n");
}

pub fn generateUpdateInput(writer: anytype, fields: []const Field, allocator: std.mem.Allocator) !void {
    _ = allocator;
    try writer.writeAll("    // Input type for updating existing records\n");
    try writer.writeAll("    pub const UpdateInput = struct {\n");

    for (fields) |field| {
        if (field.update_input) {
            const zig_type = field.type.toZigType();
            if (field.type.isOptional()) {
                try writer.print("        {s}: {s} = null,\n", .{ field.name, zig_type });
            } else {
                try writer.print("        {s}: ?{s} = null,\n", .{ field.name, zig_type });
            }
        }
    }

    try writer.writeAll("    };\n\n");
}

pub fn generateSQLMethods(writer: anytype, schema: TableSchema, struct_name: []const u8, fields: []const Field, allocator: std.mem.Allocator) !bool {
    _ = struct_name;
    // tableName - uses table name (snake_case) for SQL
    try writer.print(
        \\    // Model configuration
        \\    pub fn tableName() []const u8 {{
        \\        return "{s}";
        \\    }}
        \\
        \\
    , .{schema.name});

    // insertSQL
    try generateInsertSQL(writer, schema, fields, allocator);

    // updateSQL
    try generateUpdateSQL(writer, schema, fields, allocator);

    // upsertSQL
    const has_upsert = try generateUpsertSQL(writer, schema, fields, allocator);
    return has_upsert;
}

pub fn generateInsertSQL(writer: anytype, schema: TableSchema, fields: []const Field, allocator: std.mem.Allocator) !void {
    var arena = std.heap.ArenaAllocator.init(allocator);
    defer arena.deinit();
    const arena_allocator = arena.allocator();

    var cols = std.ArrayList([]const u8){};
    defer cols.deinit(arena_allocator);
    var params = std.ArrayList([]const u8){};
    defer params.deinit(arena_allocator);
    var param_types = std.ArrayList([]const u8){};
    defer param_types.deinit(arena_allocator);

    var param_num: usize = 1;
    for (fields) |field| {
        if (field.create_input != .excluded) {
            try cols.append(arena_allocator, field.name);

            const param_str = try std.fmt.allocPrint(arena_allocator, "${d}", .{param_num});
            if (field.create_input == .optional and field.default_value != null) {
                if (utils.typeIsnumeric(field.type)) {
                    const coalesce = try std.fmt.allocPrint(arena_allocator, "COALESCE(${d}, {s})", .{ param_num, field.default_value.? });
                    try params.append(arena_allocator, coalesce);
                } else {
                    const coalesce = try std.fmt.allocPrint(arena_allocator, "COALESCE(${d}, '{s}')", .{ param_num, field.default_value.? });
                    try params.append(arena_allocator, coalesce);
                }
            } else {
                try params.append(arena_allocator, param_str);
            }
            param_num += 1;

            const zig_type = field.type.toZigType();
            if (field.create_input == .optional) {
                if (field.type.isOptional()) {
                    try param_types.append(arena_allocator, zig_type);
                } else {
                    const optional_type = try std.fmt.allocPrint(arena_allocator, "?{s}", .{zig_type});
                    try param_types.append(arena_allocator, optional_type);
                }
            } else {
                try param_types.append(arena_allocator, zig_type);
            }
        }
    }

    const cols_str = try std.mem.join(arena_allocator, ", ", cols.items);
    const params_str = try std.mem.join(arena_allocator, ", ", params.items);

    try writer.writeAll("    pub fn insertSQL() []const u8 {\n");
    try writer.writeAll("        return\n");
    try writer.print("            \\\\INSERT INTO {s} (\n", .{schema.name});
    try writer.print("            \\\\    {s}\n", .{cols_str});
    try writer.print("            \\\\) VALUES ({s})\n", .{params_str});
    try writer.writeAll("            \\\\RETURNING id\n");
    try writer.writeAll("        ;\n");
    try writer.writeAll("    }\n\n");

    // insertParams
    try writer.writeAll("    pub fn insertParams(data: CreateInput) struct {\n");
    for (param_types.items) |ptype| {
        try writer.print("        {s},\n", .{ptype});
    }
    try writer.writeAll("    } {\n");
    try writer.writeAll("        return .{\n");

    for (fields) |field| {
        if (field.create_input != .excluded) {
            try writer.print("            data.{s},\n", .{field.name});
        }
    }

    try writer.writeAll("        };\n");
    try writer.writeAll("    }\n\n");
}

pub fn generateUpdateSQL(writer: anytype, schema: TableSchema, fields: []const Field, allocator: std.mem.Allocator) !void {
    var arena = std.heap.ArenaAllocator.init(allocator);
    defer arena.deinit();
    const arena_allocator = arena.allocator();

    var updates = std.ArrayList([]const u8){};
    defer updates.deinit(arena_allocator);
    var param_types = std.ArrayList([]const u8){};
    defer param_types.deinit(arena_allocator);

    try param_types.append(arena_allocator, "[]const u8"); // ID parameter

    var param_num: usize = 2;
    for (fields) |field| {
        if (field.update_input) {
            const update_str = try std.fmt.allocPrint(arena_allocator, "            \\\\    {s} = COALESCE(${d}, {s})", .{ field.name, param_num, field.name });
            try updates.append(arena_allocator, update_str);
            param_num += 1;

            const zig_type = field.type.toZigType();
            if (field.type.isOptional()) {
                try param_types.append(arena_allocator, zig_type);
            } else {
                const optional_type = try std.fmt.allocPrint(arena_allocator, "?{s}", .{zig_type});
                try param_types.append(arena_allocator, optional_type);
            }
        }
        if (std.mem.eql(u8, field.name, "updated_at") and !field.update_input) {
            const sqlType = field.type.toPgType();
            if (std.mem.eql(u8, sqlType, "TIMESTAMP")) {
                const update_str = try std.fmt.allocPrint(arena_allocator, "            \\\\    {s} =  CURRENT_TIMESTAMP", .{field.name});
                try updates.append(arena_allocator, update_str);
            }
        }
    }

    try writer.writeAll("    pub fn updateSQL() []const u8 {\n");
    try writer.writeAll("        return\n");
    try writer.print("            \\\\UPDATE {s} SET\n", .{schema.name});

    for (updates.items, 0..) |update, i| {
        try writer.writeAll(update);
        if (i < updates.items.len - 1) {
            try writer.writeAll(",");
        }
        try writer.writeAll("\n");
    }

    try writer.writeAll("            \\\\WHERE id = $1\n");
    try writer.writeAll("        ;\n");
    try writer.writeAll("    }\n\n");

    // updateParams
    try writer.writeAll("    pub fn updateParams(id: []const u8, data: UpdateInput) struct {\n");
    for (param_types.items) |ptype| {
        try writer.print("        {s},\n", .{ptype});
    }
    try writer.writeAll("    } {\n");
    try writer.writeAll("        return .{\n");
    try writer.writeAll("            id,\n");

    for (fields) |field| {
        if (field.update_input) {
            try writer.print("            data.{s},\n", .{field.name});
        }
    }

    try writer.writeAll("        };\n");
    try writer.writeAll("    }\n\n");
}

pub fn generateUpsertSQL(writer: anytype, schema: TableSchema, fields: []const Field, allocator: std.mem.Allocator) !bool {
    // Find unique field for ON CONFLICT
    var unique_field: ?[]const u8 = null;
    for (fields) |field| {
        if (field.unique and !field.primary_key) {
            unique_field = field.name;
            break;
        }
    }

    if (unique_field == null) {
        // No unique field, skip upsert
        return false;
    }

    var arena = std.heap.ArenaAllocator.init(allocator);
    defer arena.deinit();
    const arena_allocator = arena.allocator();

    var cols = std.ArrayList([]const u8){};
    defer cols.deinit(arena_allocator);
    var params = std.ArrayList([]const u8){};
    defer params.deinit(arena_allocator);
    var updates = std.ArrayList([]const u8){};
    defer updates.deinit(arena_allocator);

    var param_num: usize = 1;
    for (fields) |field| {
        if (field.create_input != .excluded) {
            try cols.append(arena_allocator, field.name);
            const param_str = try std.fmt.allocPrint(arena_allocator, "${d}", .{param_num});
            try params.append(arena_allocator, param_str);
            param_num += 1;

            if (!field.unique and !field.primary_key and !field.auto_generated) {
                const update_str = try std.fmt.allocPrint(arena_allocator, "            \\\\    {s} = EXCLUDED.{s}", .{ field.name, field.name });
                try updates.append(arena_allocator, update_str);
            }
        }
    }

    const cols_str = try std.mem.join(arena_allocator, ", ", cols.items);
    const params_str = try std.mem.join(arena_allocator, ", ", params.items);

    try writer.writeAll("    pub fn upsertSQL() []const u8 {\n");
    try writer.writeAll("        return\n");
    try writer.print("            \\\\INSERT INTO {s} (\n", .{schema.name});
    try writer.print("            \\\\    {s}\n", .{cols_str});
    try writer.print("            \\\\) VALUES ({s})\n", .{params_str});
    try writer.print("            \\\\ON CONFLICT ({s}) DO UPDATE SET\n", .{unique_field.?});

    for (updates.items, 0..) |update, i| {
        try writer.writeAll(update);
        if (i < updates.items.len - 1) {
            try writer.writeAll(",");
        }
        try writer.writeAll("\n");
    }

    try writer.writeAll("            \\\\RETURNING id\n");
    try writer.writeAll("        ;\n");
    try writer.writeAll("    }\n\n");

    // upsertParams (same as insertParams)
    try writer.writeAll("    pub fn upsertParams(data: CreateInput) struct {\n");
    for (fields) |field| {
        if (field.create_input != .excluded) {
            const zig_type = field.type.toZigType();
            if (field.create_input == .optional) {
                if (field.type.isOptional()) {
                    try writer.print("        {s},\n", .{zig_type});
                } else {
                    try writer.print("        ?{s},\n", .{zig_type});
                }
            } else {
                try writer.print("        {s},\n", .{zig_type});
            }
        }
    }
    try writer.writeAll("    } {\n");
    try writer.writeAll("        return .{\n");

    for (fields) |field| {
        if (field.create_input != .excluded) {
            try writer.print("            data.{s},\n", .{field.name});
        }
    }

    try writer.writeAll("        };\n");
    try writer.writeAll("    }\n\n");
    return true;
}

pub fn generateBaseModelWrapper(writer: anytype, struct_name: []const u8) !void {
    try writer.print("    const base = BaseModel({s});\n", .{struct_name});
}

pub fn generateDDLWrappers(writer: anytype) !void {
    try writer.writeAll(
        \\    // DDL operations
        \\
        \\    pub const truncate = base.truncate;
        \\
        \\    pub const tableExists = base.tableExists;
        \\
        \\
    );
}

pub fn generateCRUDWrappers(writer: anytype, struct_name: []const u8, has_upsert: bool) !void {
    _ = struct_name; // autofix
    try writer.writeAll(
        \\    // CRUD operations
        \\    pub const findById = base.findById;
        \\
        \\    pub const findAll = base.findAll;
        \\
        \\    pub const insert = base.insert;
        \\
        \\    pub const insertMany = base.insertMany;
        \\
        \\    pub const insertAndReturn = base.insertAndReturn;
        \\
        \\    pub const update = base.update;
        \\
        \\    pub const updateAndReturn = base.updateAndReturn;
        \\
        \\
    );

    if (has_upsert) {
        try writer.writeAll(
            \\    pub const upsert = base.upsert;
            \\
            \\    pub const upsertAndReturn = base.upsertAndReturn;
            \\
            \\
        );
    }

    try writer.writeAll(
        \\    pub const softDelete = base.softDelete;
        \\
        \\    pub const hardDelete = base.hardDelete;
        \\
        \\    pub const count = base.count;
        \\
        \\    pub const fromRow = base.fromRow;
        \\
        \\    pub const query = Query.init();
        \\
        \\
    );
}

pub fn generateJsonResponseHelpers(writer: anytype, struct_name: []const u8, fields: []const Field) !void {
    // Generate JsonResponse struct with UUIDs as hex strings
    try writer.writeAll("\n    /// JSON-safe response struct with UUIDs as hex strings\n");
    try writer.writeAll("    pub const JsonResponse = struct {\n");

    for (fields) |field| {
        try writer.writeAll("        ");
        try writer.print("{s}: ", .{field.name});

        // Convert UUID fields to [36]u8 hex strings
        if (field.type == .uuid) {
            try writer.writeAll("[36]u8");
        } else if (field.type == .uuid_optional) {
            try writer.writeAll("?[36]u8");
        } else {
            // Keep the same type for non-UUID fields
            const zig_type = field.type.toZigType();
            try writer.print("{s}", .{zig_type});
        }
        try writer.writeAll(",\n");
    }

    try writer.writeAll("    };\n\n");

    // Generate toJsonResponse method
    try writer.writeAll("    /// Convert model to JSON-safe response with UUIDs as hex strings\n");
    try writer.writeAll("    pub fn toJsonResponse(self: ");
    try writer.print("{s}) !JsonResponse {{\n", .{struct_name});
    try writer.writeAll("        return JsonResponse{\n");

    for (fields) |field| {
        try writer.writeAll("            .");
        try writer.print("{s} = ", .{field.name});

        // Convert UUID fields using pg.uuidToHex
        if (field.type == .uuid) {
            try writer.print("try pg.uuidToHex(&self.{s}[0..16].*)", .{field.name});
        } else if (field.type == .uuid_optional) {
            try writer.print("if (self.{s}) |id| try pg.uuidToHex(&id[0..16].*) else null", .{field.name});
        } else {
            try writer.print("self.{s}", .{field.name});
        }
        try writer.writeAll(",\n");
    }

    try writer.writeAll("        };\n");
    try writer.writeAll("    }\n\n");

    // Generate JsonResponseSafe struct (excludes redacted fields)
    try writer.writeAll("    /// JSON-safe response struct with UUIDs as hex strings (excludes redacted fields)\n");
    try writer.writeAll("    pub const JsonResponseSafe = struct {\n");

    for (fields) |field| {
        if (field.redacted) continue; // Skip redacted fields

        try writer.writeAll("        ");
        try writer.print("{s}: ", .{field.name});

        // Convert UUID fields to [36]u8 hex strings
        if (field.type == .uuid) {
            try writer.writeAll("[36]u8");
        } else if (field.type == .uuid_optional) {
            try writer.writeAll("?[36]u8");
        } else {
            // Keep the same type for non-UUID fields
            const zig_type = field.type.toZigType();
            try writer.print("{s}", .{zig_type});
        }
        try writer.writeAll(",\n");
    }

    try writer.writeAll("    };\n\n");

    // Generate toJsonResponseSafe method
    try writer.writeAll("    /// Convert model to JSON-safe response excluding redacted fields (passwords, tokens, etc.)\n");
    try writer.writeAll("    pub fn toJsonResponseSafe(self: ");
    try writer.print("{s}) !JsonResponseSafe {{\n", .{struct_name});
    try writer.writeAll("        return JsonResponseSafe{\n");

    for (fields) |field| {
        if (field.redacted) continue; // Skip redacted fields

        try writer.writeAll("            .");
        try writer.print("{s} = ", .{field.name});

        // Convert UUID fields using pg.uuidToHex
        if (field.type == .uuid) {
            try writer.print("try pg.uuidToHex(&self.{s}[0..16].*)", .{field.name});
        } else if (field.type == .uuid_optional) {
            try writer.print("if (self.{s}) |id| try pg.uuidToHex(&id[0..16].*) else null", .{field.name});
        } else {
            try writer.print("self.{s}", .{field.name});
        }
        try writer.writeAll(",\n");
    }

    try writer.writeAll("        };\n");
    try writer.writeAll("    }\n");
}

pub fn generateRelationshipMethods(writer: anytype, schema: TableSchema, struct_name: []const u8, allocator: std.mem.Allocator) !void {
    const has_relationships = schema.relationships.items.len > 0;
    const has_many_relationships = schema.has_many_relationships.items.len > 0;

    if (!has_relationships and !has_many_relationships) return;

    try writer.writeAll("    // Relationship methods\n");

    // Generate methods for regular relationships (belongsTo, hasOne, foreign)
    for (schema.relationships.items) |rel| {
        // Skip self-references for method generation - we'll use @This() for those
        const is_self_reference = std.mem.eql(u8, rel.references_table, schema.name);

        // Use PascalCase non-singular to match struct names (Comments, not Comment)
        const related_struct_name = if (is_self_reference)
            try allocator.dupe(u8, struct_name)
        else
            try utils.toPascalCaseNonSingular(allocator, rel.references_table);
        defer allocator.free(related_struct_name);

        const is_plural = (rel.relationship_type == .one_to_many or rel.relationship_type == .many_to_many);
        const method_suffix = try utils.columnToMethodName(allocator, rel.column, rel.references_table, is_plural);
        defer allocator.free(method_suffix);

        const field_name = try utils.relationshipToFieldName(allocator, rel);
        defer allocator.free(field_name);

        // Generate fetch method based on relationship type
        switch (rel.relationship_type) {
            .many_to_one => {
                // Fetch single related entity (forward relationship)
                try writer.print(
                    \\    /// Fetch the related {s} record for this {s}
                    \\    pub fn fetch{s}(self: *const {s}, db: *pg.Pool, allocator: std.mem.Allocator) !?{s} {{
                    \\        return {s}.findById(db, allocator, self.{s});
                    \\    }}
                    \\
                    \\
                , .{
                    related_struct_name,
                    struct_name,
                    method_suffix,
                    struct_name,
                    related_struct_name,
                    related_struct_name,
                    rel.column,
                });
            },
            .one_to_one => {
                // For one-to-one, check if it's forward (this table has FK) or reverse (other table has FK)
                // If column is "id", this is reverse side - need to query by foreign key
                // Otherwise, it's forward side - use findById
                if (std.mem.eql(u8, rel.column, "id")) {
                    // Reverse side: query the related table by its foreign key
                    try writer.print(
                        \\    /// Fetch the related {s} record for this {s}
                        \\    pub fn fetch{s}(self: *const {s}, db: *pg.Pool, allocator: std.mem.Allocator) !?{s} {{
                        \\        const queryt = "SELECT * FROM {s} WHERE {s} = $1 LIMIT 1";
                        \\        var result = try db.query(queryt, .{{self.id}});
                        \\        defer result.deinit();
                        \\
                        \\        if (try result.next()) |row| {{
                        \\            return try row.to({s}, .{{ .allocator = allocator, .map = .ordinal }});
                        \\        }}
                        \\        return null;
                        \\    }}
                        \\
                        \\
                    , .{
                        related_struct_name,
                        struct_name,
                        method_suffix,
                        struct_name,
                        related_struct_name,
                        rel.references_table,
                        rel.references_column,
                        related_struct_name,
                    });
                } else {
                    // Forward side: use findById
                    try writer.print(
                        \\    /// Fetch the related {s} record for this {s}
                        \\    pub fn fetch{s}(self: *const {s}, db: *pg.Pool, allocator: std.mem.Allocator) !?{s} {{
                        \\        return {s}.findById(db, allocator, self.{s});
                        \\    }}
                        \\
                        \\
                    , .{
                        related_struct_name,
                        struct_name,
                        method_suffix,
                        struct_name,
                        related_struct_name,
                        related_struct_name,
                        rel.column,
                    });
                }
            },
            .one_to_many => {
                // Fetch multiple related entities (reverse lookup)
                try writer.print(
                    \\    /// Fetch all {s} records related to this {s}
                    \\    pub fn fetch{s}(self: *const {s}, db: *pg.Pool, allocator: std.mem.Allocator) ![]{s} {{
                    \\        const queryt = "SELECT * FROM {s} WHERE {s} = $1";
                    \\        var result = try db.query(queryt, .{{self.id}});
                    \\        defer result.deinit();
                    \\
                    \\        var list = std.ArrayList({s}){{}};
                    \\        errdefer list.deinit(allocator);
                    \\
                    \\        while (try result.next()) |row| {{
                    \\            const item = try row.to({s}, .{{ .allocator = allocator, .map = .ordinal }});
                    \\            try list.append(allocator, item);
                    \\        }}
                    \\
                    \\        return try list.toOwnedSlice(allocator);
                    \\    }}
                    \\
                    \\
                , .{
                    related_struct_name,
                    struct_name,
                    method_suffix,
                    struct_name,
                    related_struct_name,
                    rel.references_table,
                    rel.references_column,
                    related_struct_name,
                    related_struct_name,
                });
            },
            .many_to_many => {
                // Many-to-many relationships are implemented via junction tables
                // Example: To get all Tags for a Post, you would:
                // 1. Query post_tags WHERE post_id = self.id
                // 2. For each result, fetch the related tag
                // This is best handled with custom methods or by directly using the junction table
                // We don't generate automatic many-to-many fetch methods as they require
                // junction table configuration and multiple queries
            },
        }
    }

    // Generate methods for hasMany relationships
    for (schema.has_many_relationships.items) |rel| {
        // Skip self-references for method generation - we'll use struct_name for those
        const is_self_reference = std.mem.eql(u8, rel.foreign_table, schema.name);

        // Use PascalCase non-singular to match struct names (Comments, not Comment)
        const related_struct_name = if (is_self_reference)
            try allocator.dupe(u8, struct_name)
        else
            try utils.toPascalCaseNonSingular(allocator, rel.foreign_table);
        defer allocator.free(related_struct_name);

        // Create method name from relationship name: "user_posts" -> "Posts"
        const method_suffix = try utils.hasManyMethodName(allocator, rel.name);
        defer allocator.free(method_suffix);

        // Generate fetchMany method
        try writer.print(
            \\    /// Fetch all related {s} records for this {s} (one-to-many)
            \\    pub fn fetch{s}(self: *const {s}, db: *pg.Pool, allocator: std.mem.Allocator) ![]{s} {{
            \\        const queryt = "SELECT * FROM {s} WHERE {s} = $1";
            \\        var result = try db.query(queryt, .{{self.{s}}});
            \\        defer result.deinit();
            \\
            \\        var list = std.ArrayList({s}){{}};
            \\        errdefer list.deinit(allocator);
            \\
            \\        while (try result.next()) |row| {{
            \\            const item = try row.to({s}, .{{ .allocator = allocator, .map = .ordinal }});
            \\            try list.append(allocator, item);
            \\        }}
            \\
            \\        return try list.toOwnedSlice(allocator);
            \\    }}
            \\
            \\
        , .{
            related_struct_name,
            struct_name,
            method_suffix,
            struct_name,
            related_struct_name,
            rel.foreign_table,
            rel.foreign_column,
            rel.local_column,
            related_struct_name,
            related_struct_name,
        });
    }
}

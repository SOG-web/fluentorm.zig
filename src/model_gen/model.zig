const std = @import("std");

const Field = @import("../schema.zig").Field;
const FieldType = @import("../schema.zig").FieldType;
const HasManyRelationship = @import("../schema.zig").HasManyRelationship;
const Relationship = @import("../schema.zig").Relationship;
const TableSchema = @import("../table.zig").TableSchema;
const utils = @import("utils.zig");

pub fn generateHeader(writer: anytype, schema_file: []const u8) !void {
    try writer.print(
        \\// AUTO-GENERATED CODE - DO NOT EDIT
        \\// Generated by scripts/generate_model.zig
        \\// Source schema: {s}
        \\// To regenerate: zig run scripts/generate_model.zig -- {s}
        \\
        \\
    , .{ schema_file, schema_file });
}

pub fn generateModelImports(writer: anytype, schema: TableSchema, allocator: std.mem.Allocator) !void {
    try writer.writeAll(
        \\const std = @import("std");
        \\const pg = @import("pg");
        \\const BaseModel = @import("../base.zig").BaseModel;
        \\const Query = @import("query.zig");
        \\const Relationship = @import("../base.zig").Relationship;
        \\const Tables = @import("../registry.zig").Tables;
        \\
    );

    // Collect all related tables from both relationships and has_many_relationships
    var seen_tables = std.StringHashMap(void).init(allocator);
    defer seen_tables.deinit();

    // Add imports from regular relationships (belongsTo, hasOne, foreign)
    for (schema.relationships.items) |rel| {
        // Skip self-references (e.g., comments referencing comments for parent_id)
        if (std.mem.eql(u8, rel.references_table, schema.name)) continue;

        if (!seen_tables.contains(rel.references_table)) {
            try seen_tables.put(rel.references_table, {});
        }
    }

    // Add imports from hasMany relationships
    for (schema.has_many_relationships.items) |rel| {
        // Skip self-references (e.g., comments has many comments for replies)
        if (std.mem.eql(u8, rel.foreign_table, schema.name)) continue;

        if (!seen_tables.contains(rel.foreign_table)) {
            try seen_tables.put(rel.foreign_table, {});
        }
    }

    // Generate imports if we have any related models
    if (seen_tables.count() > 0) {
        try writer.writeAll("\n// Related models\n");

        var iter = seen_tables.keyIterator();
        while (iter.next()) |table_name| {
            // Use PascalCase non-singular for struct reference
            const struct_name = try utils.toPascalCaseNonSingular(allocator, table_name.*);
            defer allocator.free(struct_name);

            // Use snake_case for directory name
            const dir_name = try utils.toLowerSnakeCase(allocator, table_name.*);
            defer allocator.free(dir_name);

            // Import from sibling directory: @import("../users/model.zig")
            try writer.print("const {s} = @import(\"../{s}/model.zig\");\n", .{
                struct_name,
                dir_name,
            });
            try writer.print("const {s}Query = @import(\"../{s}/query.zig\");\n", .{
                struct_name,
                dir_name,
            });
        }
    }

    try writer.writeAll("\n");
}

pub fn generateStructDefinition(writer: anytype, schema: TableSchema, struct_name: []const u8, fields: []const Field, allocator: std.mem.Allocator) !void {
    try writer.print("const {s} = @This();\n\n", .{struct_name});
    try writer.writeAll("// Fields\n");

    for (fields) |field| {
        try writer.print("    {s}: {s},\n", .{ field.name, field.type.toZigType() });
    }

    // generate field enum
    try writer.writeAll("    pub const FieldEnum = enum {\n");
    for (fields) |field| {
        try writer.print("        {s},\n", .{field.name});
    }
    try writer.writeAll("\n        pub fn isDateTime(self: @This()) bool {\n");
    try writer.writeAll("            return switch (self) {\n");
    for (fields) |field| {
        if (field.type == .timestamp or field.type == .timestamp_optional) {
            try writer.print("                .{s} => true,\n", .{field.name});
        }
    }
    try writer.writeAll("                else => false,\n");
    try writer.writeAll("            };\n");
    try writer.writeAll("        }\n");
    try writer.writeAll("    };\n");

    try writer.writeAll("    pub const RelationEnum = enum {\n");

    // Add enum members
    for (schema.relationships.items) |rel| {
        if (std.mem.eql(u8, rel.references_table, schema.name)) continue;
        const field_name = try utils.relationshipToFieldName(allocator, rel);
        defer allocator.free(field_name);
        try writer.print("        {s},\n", .{field_name});
    }
    for (schema.has_many_relationships.items) |rel| {
        if (std.mem.eql(u8, rel.foreign_table, schema.name)) continue;
        const field_name = try utils.hasManyMethodName(allocator, rel.name);
        defer allocator.free(field_name);
        // camelCase conversion
        var camel = try allocator.dupe(u8, field_name);
        defer allocator.free(camel);
        if (camel.len > 0) camel[0] = std.ascii.toLower(camel[0]);

        try writer.print("        {s},\n", .{camel});
    }
    try writer.writeAll("    };\n\n");

    // Generate metadata lookup
    try writer.writeAll("    pub fn getRelation(rel: RelationEnum) Relationship {\n");
    try writer.writeAll("        return switch (rel) {\n");

    for (schema.relationships.items) |rel| {
        if (std.mem.eql(u8, rel.references_table, schema.name)) continue;
        const field_name = try utils.relationshipToFieldName(allocator, rel);
        defer allocator.free(field_name);

        try writer.print("            .{s} => .{{ .name = \"{s}\", .type = .belongsTo, .foreign_table = .{s}, .foreign_key = .{{ .{s} = .id }}, .local_key = .{{ .{s} = .{s} }} }},\n", .{ field_name, field_name, rel.references_table, rel.references_table, schema.name, rel.column });
    }

    for (schema.has_many_relationships.items) |rel| {
        if (std.mem.eql(u8, rel.foreign_table, schema.name)) continue;
        const field_name = try utils.hasManyMethodName(allocator, rel.name);
        defer allocator.free(field_name);
        var camel = try allocator.dupe(u8, field_name);
        defer allocator.free(camel);
        if (camel.len > 0) camel[0] = std.ascii.toLower(camel[0]);

        try writer.print("            .{s} => .{{ .name = \"{s}\", .type = .hasMany, .foreign_table = .{s}, .foreign_key = .{{ .{s} = .{s} }}, .local_key = .{{ .{s} = .{s} }} }},\n", .{ camel, camel, rel.foreign_table, rel.foreign_table, rel.foreign_column, schema.name, rel.local_column });
    }

    try writer.writeAll("        };\n");
    try writer.writeAll("    }\n\n");

    for (schema.relationships.items) |rel| {
        if (std.mem.eql(u8, rel.references_table, schema.name)) continue;
        const type_name = try utils.toPascalCaseNonSingular(allocator, rel.references_table);
        defer allocator.free(type_name);

        try writer.print(
            \\    pub const {s}IncludeClauseInput = struct {{
            \\        model_name: RelationEnum,
            \\        select: []const {s}.FieldEnum = &.{{}},
            \\        where: []const {s}Query.WhereClause = &.{{}},
            \\    }};
            \\
            \\
        , .{ type_name, type_name, type_name });
    }

    for (schema.has_many_relationships.items) |rel| {
        if (std.mem.eql(u8, rel.foreign_table, schema.name)) continue;
        const type_name = try utils.toPascalCaseNonSingular(allocator, rel.foreign_table);
        defer allocator.free(type_name);

        try writer.print(
            \\    pub const {s}IncludeClauseInput = struct {{
            \\        model_name: RelationEnum,
            \\        select: []const {s}.FieldEnum = &.{{}},
            \\        where: []const {s}Query.WhereClause = &.{{}},
            \\    }};
            \\
            \\
        , .{ type_name, type_name, type_name });
    }

    try writer.writeAll("    pub const IncludeClauseInput = union(RelationEnum) {\n");

    for (schema.relationships.items) |rel| {
        if (std.mem.eql(u8, rel.references_table, schema.name)) continue;
        const field_name = try utils.relationshipToFieldName(allocator, rel);
        defer allocator.free(field_name);
        const type_name = try utils.toPascalCaseNonSingular(allocator, rel.references_table);
        defer allocator.free(type_name);

        try writer.print("        {s}: {s}IncludeClauseInput,\n", .{ field_name, type_name });
    }

    for (schema.has_many_relationships.items) |rel| {
        if (std.mem.eql(u8, rel.foreign_table, schema.name)) continue;
        const field_name = try utils.hasManyMethodName(allocator, rel.name);
        defer allocator.free(field_name);
        var camel = try allocator.dupe(u8, field_name);
        defer allocator.free(camel);
        if (camel.len > 0) camel[0] = std.ascii.toLower(camel[0]);

        const type_name = try utils.toPascalCaseNonSingular(allocator, rel.foreign_table);
        defer allocator.free(type_name);

        try writer.print("        {s}: {s}IncludeClauseInput,\n", .{ camel, type_name });
    }
    try writer.writeAll("    };\n\n");
}

pub fn generateDeinit(writer: anytype, fields: []const Field, allocator: std.mem.Allocator) !void {
    _ = allocator;
    try writer.writeAll("    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {\n");

    for (fields) |field| {
        const zig_type = field.type.toZigType();
        if (std.mem.eql(u8, zig_type, "[]const u8") or std.mem.eql(u8, zig_type, "?[]const u8")) {
            if (field.type.isOptional()) {
                try writer.print("        if (self.{s}) |v| allocator.free(v);\n", .{field.name});
            } else {
                try writer.print("        allocator.free(self.{s});\n", .{field.name});
            }
        }
    }

    try writer.writeAll("    }\n\n");
}

pub fn generateCreateInput(writer: anytype, fields: []const Field, allocator: std.mem.Allocator) !void {
    _ = allocator;
    try writer.writeAll("    // Input type for creating new records\n");
    try writer.writeAll("    pub const CreateInput = struct {\n");

    for (fields) |field| {
        if (field.create_input == .required) {
            try writer.print("        {s}: {s},\n", .{ field.name, field.type.toZigType() });
        } else if (field.create_input == .optional) {
            const zig_type = field.type.toZigType();
            if (field.type.isOptional()) {
                try writer.print("        {s}: {s} = null,\n", .{ field.name, zig_type });
            } else {
                try writer.print("        {s}: ?{s} = null,\n", .{ field.name, zig_type });
            }
        }
    }

    try writer.writeAll("    };\n\n");
}

pub fn generateUpdateInput(writer: anytype, fields: []const Field, allocator: std.mem.Allocator) !void {
    _ = allocator;
    try writer.writeAll("    // Input type for updating existing records\n");
    try writer.writeAll("    pub const UpdateInput = struct {\n");

    for (fields) |field| {
        if (field.update_input) {
            const zig_type = field.type.toZigType();
            if (field.type.isOptional()) {
                try writer.print("        {s}: {s} = null,\n", .{ field.name, zig_type });
            } else {
                try writer.print("        {s}: ?{s} = null,\n", .{ field.name, zig_type });
            }
        }
    }

    try writer.writeAll("    };\n\n");
}

pub fn generateSQLMethods(writer: anytype, schema: TableSchema, struct_name: []const u8, fields: []const Field, allocator: std.mem.Allocator) !bool {
    _ = struct_name;
    // tableName - uses table name (snake_case) for SQL
    // Generate json_all_fields_sql
    var json_fields = std.ArrayList(u8){};
    defer json_fields.deinit(allocator);
    for (fields, 0..) |field, i| {
        if (field.type == .timestamp or field.type == .timestamp_optional) {
            try json_fields.writer(allocator).print("'{s}', (extract(epoch from {s}) * 1000000)::bigint", .{ field.name, field.name });
        } else {
            try json_fields.writer(allocator).print("'{s}', {s}", .{ field.name, field.name });
        }
        if (i < fields.len - 1) try json_fields.appendSlice(allocator, ", ");
    }

    try writer.print(
        \\    // Model configuration
        \\    pub fn tableName() []const u8 {{
        \\        return "{s}";
        \\    }}
        \\
        \\    pub const json_all_fields_sql = "jsonb_build_object({s})";
        \\
        \\
    , .{ schema.name, json_fields.items });

    // insertSQL
    try generateInsertSQL(writer, schema, fields, allocator);

    // updateSQL
    try generateUpdateSQL(writer, schema, fields, allocator);

    // upsertSQL
    const has_upsert = try generateUpsertSQL(writer, schema, fields, allocator);
    return has_upsert;
}

pub fn generateInsertSQL(writer: anytype, schema: TableSchema, fields: []const Field, allocator: std.mem.Allocator) !void {
    var arena = std.heap.ArenaAllocator.init(allocator);
    defer arena.deinit();
    const arena_allocator = arena.allocator();

    var cols = std.ArrayList([]const u8){};
    defer cols.deinit(arena_allocator);
    var params = std.ArrayList([]const u8){};
    defer params.deinit(arena_allocator);
    var param_types = std.ArrayList([]const u8){};
    defer param_types.deinit(arena_allocator);

    var param_num: usize = 1;
    for (fields) |field| {
        if (field.create_input != .excluded) {
            try cols.append(arena_allocator, field.name);

            const param_str = try std.fmt.allocPrint(arena_allocator, "${d}", .{param_num});
            if (field.create_input == .optional and field.default_value != null and !std.mem.eql(u8, field.default_value.?, "skip")) {
                if (utils.shouldQuoteDefault(field.type, field.default_value.?)) {
                    const coalesce = try std.fmt.allocPrint(arena_allocator, "COALESCE(${d}, '{s}')", .{ param_num, field.default_value.? });
                    try params.append(arena_allocator, coalesce);
                } else {
                    const coalesce = try std.fmt.allocPrint(arena_allocator, "COALESCE(${d}, {s})", .{ param_num, field.default_value.? });
                    try params.append(arena_allocator, coalesce);
                }
            } else {
                try params.append(arena_allocator, param_str);
            }
            param_num += 1;

            const zig_type = field.type.toZigType();
            if (field.create_input == .optional) {
                if (field.type.isOptional()) {
                    try param_types.append(arena_allocator, zig_type);
                } else {
                    const optional_type = try std.fmt.allocPrint(arena_allocator, "?{s}", .{zig_type});
                    try param_types.append(arena_allocator, optional_type);
                }
            } else {
                try param_types.append(arena_allocator, zig_type);
            }
        }
    }

    const cols_str = try std.mem.join(arena_allocator, ", ", cols.items);
    const params_str = try std.mem.join(arena_allocator, ", ", params.items);

    try writer.writeAll("    pub fn insertSQL() []const u8 {\n");
    try writer.writeAll("        return\n");
    try writer.print("            \\\\INSERT INTO {s} (\n", .{schema.name});
    try writer.print("            \\\\    {s}\n", .{cols_str});
    try writer.print("            \\\\) VALUES ({s})\n", .{params_str});
    try writer.writeAll("            \\\\RETURNING id\n");
    try writer.writeAll("        ;\n");
    try writer.writeAll("    }\n\n");

    // insertParams
    try writer.writeAll("    pub fn insertParams(data: CreateInput) struct {\n");
    for (param_types.items) |ptype| {
        try writer.print("        {s},\n", .{ptype});
    }
    try writer.writeAll("    } {\n");
    try writer.writeAll("        return .{\n");

    for (fields) |field| {
        if (field.create_input != .excluded) {
            try writer.print("            data.{s},\n", .{field.name});
        }
    }

    try writer.writeAll("        };\n");
    try writer.writeAll("    }\n\n");
}

pub fn generateUpdateSQL(writer: anytype, schema: TableSchema, fields: []const Field, allocator: std.mem.Allocator) !void {
    var arena = std.heap.ArenaAllocator.init(allocator);
    defer arena.deinit();
    const arena_allocator = arena.allocator();

    var updates = std.ArrayList([]const u8){};
    defer updates.deinit(arena_allocator);
    var param_types = std.ArrayList([]const u8){};
    defer param_types.deinit(arena_allocator);

    try param_types.append(arena_allocator, "[]const u8"); // ID parameter

    var param_num: usize = 2;
    for (fields) |field| {
        if (field.update_input) {
            const update_str = try std.fmt.allocPrint(arena_allocator, "            \\\\    {s} = COALESCE(${d}, {s})", .{ field.name, param_num, field.name });
            try updates.append(arena_allocator, update_str);
            param_num += 1;

            const zig_type = field.type.toZigType();
            if (field.type.isOptional()) {
                try param_types.append(arena_allocator, zig_type);
            } else {
                const optional_type = try std.fmt.allocPrint(arena_allocator, "?{s}", .{zig_type});
                try param_types.append(arena_allocator, optional_type);
            }
        }
        if (std.mem.eql(u8, field.name, "updated_at") and !field.update_input) {
            const sqlType = field.type.toPgType();
            if (std.mem.eql(u8, sqlType, "TIMESTAMP")) {
                const update_str = try std.fmt.allocPrint(arena_allocator, "            \\\\    {s} =  CURRENT_TIMESTAMP", .{field.name});
                try updates.append(arena_allocator, update_str);
            }
        }
    }

    try writer.writeAll("    pub fn updateSQL() []const u8 {\n");
    try writer.writeAll("        return\n");
    try writer.print("            \\\\UPDATE {s} SET\n", .{schema.name});

    for (updates.items, 0..) |update, i| {
        try writer.writeAll(update);
        if (i < updates.items.len - 1) {
            try writer.writeAll(",");
        }
        try writer.writeAll("\n");
    }

    try writer.writeAll("            \\\\WHERE id = $1\n");
    try writer.writeAll("        ;\n");
    try writer.writeAll("    }\n\n");

    // updateParams
    try writer.writeAll("    pub fn updateParams(id: []const u8, data: UpdateInput) struct {\n");
    for (param_types.items) |ptype| {
        try writer.print("        {s},\n", .{ptype});
    }
    try writer.writeAll("    } {\n");
    try writer.writeAll("        return .{\n");
    try writer.writeAll("            id,\n");

    for (fields) |field| {
        if (field.update_input) {
            try writer.print("            data.{s},\n", .{field.name});
        }
    }

    try writer.writeAll("        };\n");
    try writer.writeAll("    }\n\n");
}

pub fn generateUpsertSQL(writer: anytype, schema: TableSchema, fields: []const Field, allocator: std.mem.Allocator) !bool {
    // Find unique field for ON CONFLICT
    var unique_field: ?[]const u8 = null;
    for (fields) |field| {
        if (field.unique and !field.primary_key) {
            unique_field = field.name;
            break;
        }
    }

    if (unique_field == null) {
        // No unique field, skip upsert
        return false;
    }

    var arena = std.heap.ArenaAllocator.init(allocator);
    defer arena.deinit();
    const arena_allocator = arena.allocator();

    var cols = std.ArrayList([]const u8){};
    defer cols.deinit(arena_allocator);
    var params = std.ArrayList([]const u8){};
    defer params.deinit(arena_allocator);
    var updates = std.ArrayList([]const u8){};
    defer updates.deinit(arena_allocator);

    var param_num: usize = 1;
    for (fields) |field| {
        if (field.create_input != .excluded) {
            try cols.append(arena_allocator, field.name);
            const param_str = try std.fmt.allocPrint(arena_allocator, "${d}", .{param_num});
            try params.append(arena_allocator, param_str);
            param_num += 1;

            if (!field.unique and !field.primary_key and !field.auto_generated) {
                const update_str = try std.fmt.allocPrint(arena_allocator, "            \\\\    {s} = EXCLUDED.{s}", .{ field.name, field.name });
                try updates.append(arena_allocator, update_str);
            }
        }
    }

    const cols_str = try std.mem.join(arena_allocator, ", ", cols.items);
    const params_str = try std.mem.join(arena_allocator, ", ", params.items);

    try writer.writeAll("    pub fn upsertSQL() []const u8 {\n");
    try writer.writeAll("        return\n");
    try writer.print("            \\\\INSERT INTO {s} (\n", .{schema.name});
    try writer.print("            \\\\    {s}\n", .{cols_str});
    try writer.print("            \\\\) VALUES ({s})\n", .{params_str});
    try writer.print("            \\\\ON CONFLICT ({s}) DO UPDATE SET\n", .{unique_field.?});

    for (updates.items, 0..) |update, i| {
        try writer.writeAll(update);
        if (i < updates.items.len - 1) {
            try writer.writeAll(",");
        }
        try writer.writeAll("\n");
    }

    try writer.writeAll("            \\\\RETURNING id\n");
    try writer.writeAll("        ;\n");
    try writer.writeAll("    }\n\n");

    // upsertParams (same as insertParams)
    try writer.writeAll("    pub fn upsertParams(data: CreateInput) struct {\n");
    for (fields) |field| {
        if (field.create_input != .excluded) {
            const zig_type = field.type.toZigType();
            if (field.create_input == .optional) {
                if (field.type.isOptional()) {
                    try writer.print("        {s},\n", .{zig_type});
                } else {
                    try writer.print("        ?{s},\n", .{zig_type});
                }
            } else {
                try writer.print("        {s},\n", .{zig_type});
            }
        }
    }
    try writer.writeAll("    } {\n");
    try writer.writeAll("        return .{\n");

    for (fields) |field| {
        if (field.create_input != .excluded) {
            try writer.print("            data.{s},\n", .{field.name});
        }
    }

    try writer.writeAll("        };\n");
    try writer.writeAll("    }\n\n");
    return true;
}

pub fn generateBaseModelWrapper(writer: anytype, struct_name: []const u8) !void {
    try writer.print("    const base = BaseModel({s});\n", .{struct_name});
}

pub fn generateDDLWrappers(writer: anytype) !void {
    try writer.writeAll(
        \\    // DDL operations
        \\
        \\    pub const truncate = base.truncate;
        \\
        \\    pub const tableExists = base.tableExists;
        \\
        \\
    );
}

pub fn generateCRUDWrappers(writer: anytype, struct_name: []const u8, has_upsert: bool) !void {
    _ = struct_name; // autofix
    try writer.writeAll(
        \\    // CRUD operations
        \\    pub const findById = base.findById;
        \\
        \\    pub const findAll = base.findAll;
        \\
        \\    pub const insert = base.insert;
        \\
        \\    pub const insertMany = base.insertMany;
        \\
        \\    pub const insertAndReturn = base.insertAndReturn;
        \\
        \\    pub const update = base.update;
        \\
        \\    pub const updateAndReturn = base.updateAndReturn;
        \\
        \\
    );

    if (has_upsert) {
        try writer.writeAll(
            \\    pub const upsert = base.upsert;
            \\
            \\    pub const upsertAndReturn = base.upsertAndReturn;
            \\
            \\
        );
    }

    try writer.writeAll(
        \\    pub const softDelete = base.softDelete;
        \\
        \\    pub const hardDelete = base.hardDelete;
        \\
        \\    pub const count = base.count;
        \\
        \\    pub const fromRow = base.fromRow;
        \\
        \\    pub const query = Query.init;
        \\
        \\    pub const queryWithArena = Query.initWithArena;
        \\
        \\    pub const queryWithAllocator = Query.initWithAllocator;
        \\
        \\
    );
}

pub fn generateJsonResponseHelpers(writer: anytype, struct_name: []const u8, fields: []const Field) !void {
    // Generate JsonResponse struct with UUIDs as hex strings
    try writer.writeAll("\n    /// JSON-safe response struct with UUIDs as hex strings\n");
    try writer.writeAll("    pub const JsonResponse = struct {\n");

    for (fields) |field| {
        try writer.writeAll("        ");
        try writer.print("{s}: ", .{field.name});

        // Convert UUID fields to [36]u8 hex strings
        if (field.type == .uuid) {
            try writer.writeAll("[36]u8");
        } else if (field.type == .uuid_optional) {
            try writer.writeAll("?[36]u8");
        } else {
            // Keep the same type for non-UUID fields
            const zig_type = field.type.toZigType();
            try writer.print("{s}", .{zig_type});
        }
        try writer.writeAll(",\n");
    }

    try writer.writeAll("    };\n\n");

    // Generate toJsonResponse method
    try writer.writeAll("    /// Convert model to JSON-safe response with UUIDs as hex strings\n");
    try writer.writeAll("    pub fn toJsonResponse(self: ");
    try writer.print("{s}) !JsonResponse {{\n", .{struct_name});
    try writer.writeAll("        return JsonResponse{\n");

    for (fields) |field| {
        try writer.writeAll("            .");
        try writer.print("{s} = ", .{field.name});

        // Convert UUID fields using pg.uuidToHex
        if (field.type == .uuid) {
            try writer.print("try pg.uuidToHex(&self.{s}[0..16].*)", .{field.name});
        } else if (field.type == .uuid_optional) {
            try writer.print("if (self.{s}) |id| try pg.uuidToHex(&id[0..16].*) else null", .{field.name});
        } else {
            try writer.print("self.{s}", .{field.name});
        }
        try writer.writeAll(",\n");
    }

    try writer.writeAll("        };\n");
    try writer.writeAll("    }\n\n");

    // Generate JsonResponseSafe struct (excludes redacted fields)
    try writer.writeAll("    /// JSON-safe response struct with UUIDs as hex strings (excludes redacted fields)\n");
    try writer.writeAll("    pub const JsonResponseSafe = struct {\n");

    for (fields) |field| {
        if (field.redacted) continue; // Skip redacted fields

        try writer.writeAll("        ");
        try writer.print("{s}: ", .{field.name});

        // Convert UUID fields to [36]u8 hex strings
        if (field.type == .uuid) {
            try writer.writeAll("[36]u8");
        } else if (field.type == .uuid_optional) {
            try writer.writeAll("?[36]u8");
        } else {
            // Keep the same type for non-UUID fields
            const zig_type = field.type.toZigType();
            try writer.print("{s}", .{zig_type});
        }
        try writer.writeAll(",\n");
    }

    try writer.writeAll("    };\n\n");

    // Generate toJsonResponseSafe method
    try writer.writeAll("    /// Convert model to JSON-safe response excluding redacted fields (passwords, tokens, etc.)\n");
    try writer.writeAll("    pub fn toJsonResponseSafe(self: ");
    try writer.print("{s}) !JsonResponseSafe {{\n", .{struct_name});
    try writer.writeAll("        return JsonResponseSafe{\n");

    for (fields) |field| {
        if (field.redacted) continue; // Skip redacted fields

        try writer.writeAll("            .");
        try writer.print("{s} = ", .{field.name});

        // Convert UUID fields using pg.uuidToHex
        if (field.type == .uuid) {
            try writer.print("try pg.uuidToHex(&self.{s}[0..16].*)", .{field.name});
        } else if (field.type == .uuid_optional) {
            try writer.print("if (self.{s}) |id| try pg.uuidToHex(&id[0..16].*) else null", .{field.name});
        } else {
            try writer.print("self.{s}", .{field.name});
        }
        try writer.writeAll(",\n");
    }

    try writer.writeAll("        };\n");
    try writer.writeAll("    }\n");
}

pub fn generateRelationshipMethods(writer: anytype, schema: TableSchema, struct_name: []const u8, allocator: std.mem.Allocator) !void {
    const has_relationships = schema.relationships.items.len > 0;
    const has_many_relationships = schema.has_many_relationships.items.len > 0;

    if (!has_relationships and !has_many_relationships) return;

    try writer.writeAll("    // Relationship methods\n");

    // Generate methods for regular relationships (belongsTo, hasOne, foreign)
    for (schema.relationships.items) |rel| {
        // Skip self-references for method generation - we'll use @This() for those
        const is_self_reference = std.mem.eql(u8, rel.references_table, schema.name);

        // Use PascalCase non-singular to match struct names (Comments, not Comment)
        const related_struct_name = if (is_self_reference)
            try allocator.dupe(u8, struct_name)
        else
            try utils.toPascalCaseNonSingular(allocator, rel.references_table);
        defer allocator.free(related_struct_name);

        const is_plural = (rel.relationship_type == .one_to_many or rel.relationship_type == .many_to_many);
        const method_suffix = try utils.columnToMethodName(allocator, rel.column, rel.references_table, is_plural);
        defer allocator.free(method_suffix);

        const field_name = try utils.relationshipToFieldName(allocator, rel);
        defer allocator.free(field_name);

        // Generate fetch method based on relationship type
        switch (rel.relationship_type) {
            .many_to_one => {
                // Fetch single related entity (forward relationship)
                try writer.print(
                    \\    /// Fetch the related {s} record for this {s}
                    \\    pub fn fetch{s}(self: *const {s}, db: *pg.Pool, allocator: std.mem.Allocator) !?{s} {{
                    \\        return {s}.findById(db, allocator, self.{s});
                    \\    }}
                    \\
                    \\
                , .{
                    related_struct_name,
                    struct_name,
                    method_suffix,
                    struct_name,
                    related_struct_name,
                    related_struct_name,
                    rel.column,
                });
            },
            .one_to_one => {
                // For one-to-one, check if it's forward (this table has FK) or reverse (other table has FK)
                // If column is "id", this is reverse side - need to query by foreign key
                // Otherwise, it's forward side - use findById
                if (std.mem.eql(u8, rel.column, "id")) {
                    // Reverse side: query the related table by its foreign key
                    try writer.print(
                        \\    /// Fetch the related {s} record for this {s}
                        \\    pub fn fetch{s}(self: *const {s}, db: *pg.Pool, allocator: std.mem.Allocator) !?{s} {{
                        \\        const queryt = "SELECT * FROM {s} WHERE {s} = $1 LIMIT 1";
                        \\        var result = try db.query(queryt, .{{self.id}});
                        \\        defer result.deinit();
                        \\
                        \\        if (try result.next()) |row| {{
                        \\            return try row.to({s}, .{{ .allocator = allocator, .map = .ordinal }});
                        \\        }}
                        \\        return null;
                        \\    }}
                        \\
                        \\
                    , .{
                        related_struct_name,
                        struct_name,
                        method_suffix,
                        struct_name,
                        related_struct_name,
                        rel.references_table,
                        rel.references_column,
                        related_struct_name,
                    });
                } else {
                    // Forward side: use findById
                    try writer.print(
                        \\    /// Fetch the related {s} record for this {s}
                        \\    pub fn fetch{s}(self: *const {s}, db: *pg.Pool, allocator: std.mem.Allocator) !?{s} {{
                        \\        return {s}.findById(db, allocator, self.{s});
                        \\    }}
                        \\
                        \\
                    , .{
                        related_struct_name,
                        struct_name,
                        method_suffix,
                        struct_name,
                        related_struct_name,
                        related_struct_name,
                        rel.column,
                    });
                }
            },
            .one_to_many => {
                // Fetch multiple related entities (reverse lookup)
                try writer.print(
                    \\    /// Fetch all {s} records related to this {s}
                    \\    pub fn fetch{s}(self: *const {s}, db: *pg.Pool, allocator: std.mem.Allocator) ![]{s} {{
                    \\        const queryt = "SELECT * FROM {s} WHERE {s} = $1";
                    \\        var result = try db.query(queryt, .{{self.id}});
                    \\        defer result.deinit();
                    \\
                    \\        var list = std.ArrayList({s}){{}};
                    \\        errdefer list.deinit(allocator);
                    \\
                    \\        while (try result.next()) |row| {{
                    \\            const item = try row.to({s}, .{{ .allocator = allocator, .map = .ordinal }});
                    \\            try list.append(allocator, item);
                    \\        }}
                    \\
                    \\        return try list.toOwnedSlice(allocator);
                    \\    }}
                    \\
                    \\
                , .{
                    related_struct_name,
                    struct_name,
                    method_suffix,
                    struct_name,
                    related_struct_name,
                    rel.references_table,
                    rel.references_column,
                    related_struct_name,
                    related_struct_name,
                });
            },
            .many_to_many => {
                // Many-to-many relationships are implemented via junction tables
                // Example: To get all Tags for a Post, you would:
                // 1. Query post_tags WHERE post_id = self.id
                // 2. For each result, fetch the related tag
                // This is best handled with custom methods or by directly using the junction table
                // We don't generate automatic many-to-many fetch methods as they require
                // junction table configuration and multiple queries
            },
        }
    }

    // Generate methods for hasMany relationships
    for (schema.has_many_relationships.items) |rel| {
        // Skip self-references for method generation - we'll use struct_name for those
        const is_self_reference = std.mem.eql(u8, rel.foreign_table, schema.name);

        // Use PascalCase non-singular to match struct names (Comments, not Comment)
        const related_struct_name = if (is_self_reference)
            try allocator.dupe(u8, struct_name)
        else
            try utils.toPascalCaseNonSingular(allocator, rel.foreign_table);
        defer allocator.free(related_struct_name);

        // Create method name from relationship name: "user_posts" -> "Posts"
        const method_suffix = try utils.hasManyMethodName(allocator, rel.name);
        defer allocator.free(method_suffix);

        // Generate fetchMany method
        try writer.print(
            \\    /// Fetch all related {s} records for this {s} (one-to-many)
            \\    pub fn fetch{s}(self: *const {s}, db: *pg.Pool, allocator: std.mem.Allocator) ![]{s} {{
            \\        const queryt = "SELECT * FROM {s} WHERE {s} = $1";
            \\        var result = try db.query(queryt, .{{self.{s}}});
            \\        defer result.deinit();
            \\
            \\        var list = std.ArrayList({s}){{}};
            \\        errdefer list.deinit(allocator);
            \\
            \\        while (try result.next()) |row| {{
            \\            const item = try row.to({s}, .{{ .allocator = allocator, .map = .ordinal }});
            \\            try list.append(allocator, item);
            \\        }}
            \\
            \\        return try list.toOwnedSlice(allocator);
            \\    }}
            \\
            \\
        , .{
            related_struct_name,
            struct_name,
            method_suffix,
            struct_name,
            related_struct_name,
            rel.foreign_table,
            rel.foreign_column,
            rel.local_column,
            related_struct_name,
            related_struct_name,
        });
    }
}

/// Generate rel.zig file with explicit relation types for full IntelliSense support.
/// Creates types like `UsersWithPosts`, `UsersWithComments`, `UsersWithAllRelations`.
pub fn generateRelationTypes(writer: anytype, schema: TableSchema, struct_name: []const u8, fields: []const Field, allocator: std.mem.Allocator) !void {
    // Collect all relation info
    var relations = std.ArrayList(RelationInfo){};
    defer relations.deinit(allocator);

    // Regular relationships (belongsTo, hasOne)
    for (schema.relationships.items) |rel| {
        if (std.mem.eql(u8, rel.references_table, schema.name)) continue;

        const field_name = try utils.relationshipToFieldName(allocator, rel);
        const related_type = try utils.toPascalCaseNonSingular(allocator, rel.references_table);
        const is_many = rel.relationship_type == .one_to_many or rel.relationship_type == .many_to_many;

        try relations.append(allocator, .{
            .field_name = field_name,
            .related_type = related_type,
            .is_many = is_many,
            .foreign_table = try allocator.dupe(u8, rel.references_table),
        });
    }

    // HasMany relationships
    for (schema.has_many_relationships.items) |rel| {
        if (std.mem.eql(u8, rel.foreign_table, schema.name)) continue;

        const field_name = try utils.hasManyMethodName(allocator, rel.name);
        var camel = try allocator.dupe(u8, field_name);
        if (camel.len > 0) camel[0] = std.ascii.toLower(camel[0]);
        allocator.free(field_name);

        const related_type = try utils.toPascalCaseNonSingular(allocator, rel.foreign_table);

        try relations.append(allocator, .{
            .field_name = camel,
            .related_type = related_type,
            .is_many = true,
            .foreign_table = try allocator.dupe(u8, rel.foreign_table),
        });
    }

    if (relations.items.len == 0) return;

    // Generate file header
    try writer.writeAll(
        \\// AUTO-GENERATED CODE - DO NOT EDIT
        \\// Explicit relation types for full ZLS IntelliSense support
        \\
        \\const std = @import("std");
        \\const Row = @import("pg").Row;
        \\const Model = @import("model.zig");
        \\
    );

    // Import related models
    var seen = std.StringHashMap(void).init(allocator);
    defer seen.deinit();
    for (relations.items) |rel| {
        if (!seen.contains(rel.foreign_table)) {
            try seen.put(rel.foreign_table, {});
            const snake_name = try utils.toLowerSnakeCase(allocator, rel.foreign_table);
            defer allocator.free(snake_name);
            try writer.print("const {s} = @import(\"../{s}/model.zig\");\n", .{ rel.related_type, snake_name });
        }
    }

    try writer.writeAll("\n");

    // Generate individual relation types: UsersWithPosts, UsersWithComments, etc.
    for (relations.items) |rel| {
        const type_name = try std.fmt.allocPrint(allocator, "{s}With{s}", .{ struct_name, rel.related_type });
        defer allocator.free(type_name);

        try writer.print("/// {s} with {s} relation loaded\n", .{ struct_name, rel.field_name });
        try writer.print("pub const {s} = struct {{\n", .{type_name});

        // Add all base fields
        for (fields) |field| {
            try writer.print("    {s}: {s},\n", .{ field.name, field.type.toZigType() });
        }

        // Add relation field
        if (rel.is_many) {
            try writer.print("    {s}: ?[]{s} = null,\n", .{ rel.field_name, rel.related_type });
        } else {
            try writer.print("    {s}: ?{s} = null,\n", .{ rel.field_name, rel.related_type });
        }

        try writer.writeAll("\n");

        // Generate fromBase helper
        try writer.print("    /// Create from a base {s} model with relation set to null\n", .{struct_name});
        try writer.print("    pub fn fromBase(model: Model) @This() {{\n", .{});
        try writer.writeAll("        return .{\n");
        for (fields) |field| {
            try writer.print("            .{s} = model.{s},\n", .{ field.name, field.name });
        }
        try writer.print("            .{s} = null,\n", .{rel.field_name});
        try writer.writeAll("        };\n");
        try writer.writeAll("    }\n\n");

        // Generate toBase helper
        try writer.print("    /// Extract the base {s} model (without relation)\n", .{struct_name});
        try writer.writeAll("    pub fn toBase(self: @This()) Model {\n");
        try writer.writeAll("        return .{\n");
        for (fields) |field| {
            try writer.print("            .{s} = self.{s},\n", .{ field.name, field.name });
        }
        try writer.writeAll("        };\n");
        try writer.writeAll("    }\n\n");

        // Generate fromRow helper that parses JSONB
        try writer.writeAll("    /// Create from a database row, parsing JSONB relation columns.\n");
        try writer.writeAll("    /// Use this with query results that include relations via LEFT JOIN.\n");
        try writer.print("    pub fn fromRow(row: Row, allocator: std.mem.Allocator) !@This() {{\n", .{});
        try writer.writeAll("        var result: @This() = undefined;\n\n");

        // Map base fields
        try writer.writeAll("        // Map base fields\n");
        for (fields) |field| {
            try writer.print("        result.{s} = row.getCol({s}, \"{s}\");\n", .{
                field.name,
                field.type.toZigType(),
                field.name,
            });
        }

        try writer.writeAll("\n");

        // Parse JSONB relation field
        try writer.print("        // Parse JSONB relation: {s}\n", .{rel.field_name});
        try writer.print("        const {s}_json = row.getCol(?[]const u8, \"{s}\");\n", .{ rel.field_name, rel.field_name });
        try writer.print("        if ({s}_json) |json_str| {{\n", .{rel.field_name});
        if (rel.is_many) {
            try writer.print("            if (std.json.parseFromSlice([]{s}, allocator, json_str, .{{}})) |parsed| {{\n", .{rel.related_type});
            try writer.print("                result.{s} = parsed.value;\n", .{rel.field_name});
            try writer.writeAll("            } else |_| {\n");
            try writer.print("                result.{s} = null;\n", .{rel.field_name});
            try writer.writeAll("            }\n");
        } else {
            try writer.print("            if (std.json.parseFromSlice({s}, allocator, json_str, .{{}})) |parsed| {{\n", .{rel.related_type});
            try writer.print("                result.{s} = parsed.value;\n", .{rel.field_name});
            try writer.writeAll("            } else |_| {\n");
            try writer.print("                result.{s} = null;\n", .{rel.field_name});
            try writer.writeAll("            }\n");
        }
        try writer.writeAll("        } else {\n");
        try writer.print("            result.{s} = null;\n", .{rel.field_name});
        try writer.writeAll("        }\n\n");

        try writer.writeAll("        return result;\n");
        try writer.writeAll("    }\n");

        try writer.writeAll("};\n\n");
    }

    // Generate WithAllRelations type if there are multiple relations
    if (relations.items.len > 1) {
        try writer.print("/// {s} with all relations loaded\n", .{struct_name});
        try writer.print("pub const {s}WithAllRelations = struct {{\n", .{struct_name});

        // Add all base fields
        for (fields) |field| {
            try writer.print("    {s}: {s},\n", .{ field.name, field.type.toZigType() });
        }

        // Add all relation fields
        for (relations.items) |rel| {
            if (rel.is_many) {
                try writer.print("    {s}: ?[]{s} = null,\n", .{ rel.field_name, rel.related_type });
            } else {
                try writer.print("    {s}: ?{s} = null,\n", .{ rel.field_name, rel.related_type });
            }
        }

        try writer.writeAll("\n");

        // Generate fromBase helper
        try writer.print("    /// Create from a base {s} model with all relations set to null\n", .{struct_name});
        try writer.writeAll("    pub fn fromBase(model: Model) @This() {\n");
        try writer.writeAll("        return .{\n");
        for (fields) |field| {
            try writer.print("            .{s} = model.{s},\n", .{ field.name, field.name });
        }
        for (relations.items) |rel| {
            try writer.print("            .{s} = null,\n", .{rel.field_name});
        }
        try writer.writeAll("        };\n");
        try writer.writeAll("    }\n\n");

        // Generate toBase helper
        try writer.print("    /// Extract the base {s} model (without relations)\n", .{struct_name});
        try writer.writeAll("    pub fn toBase(self: @This()) Model {\n");
        try writer.writeAll("        return .{\n");
        for (fields) |field| {
            try writer.print("            .{s} = self.{s},\n", .{ field.name, field.name });
        }
        try writer.writeAll("        };\n");
        try writer.writeAll("    }\n\n");

        // Generate fromRow helper that parses all JSONB relations
        try writer.writeAll("    /// Create from a database row, parsing all JSONB relation columns.\n");
        try writer.writeAll("    /// Use this with query results that include relations via LEFT JOIN.\n");
        try writer.print("    pub fn fromRow(row: Row, allocator: std.mem.Allocator) !@This() {{\n", .{});
        try writer.writeAll("        var result: @This() = undefined;\n\n");

        // Map base fields
        try writer.writeAll("        // Map base fields\n");
        for (fields) |field| {
            try writer.print("        result.{s} = row.getCol({s}, \"{s}\");\n", .{
                field.name,
                field.type.toZigType(),
                field.name,
            });
        }

        try writer.writeAll("\n        // Parse JSONB relations\n");

        // Parse all JSONB relation fields
        for (relations.items) |rel| {
            try writer.print("        const {s}_json = row.getCol(?[]const u8, \"{s}\");\n", .{ rel.field_name, rel.field_name });
            try writer.print("        if ({s}_json) |json_str| {{\n", .{rel.field_name});
            if (rel.is_many) {
                try writer.print("            if (std.json.parseFromSlice([]{s}, allocator, json_str, .{{}})) |parsed| {{\n", .{rel.related_type});
                try writer.print("                result.{s} = parsed.value;\n", .{rel.field_name});
                try writer.writeAll("            } else |_| {\n");
                try writer.print("                result.{s} = null;\n", .{rel.field_name});
                try writer.writeAll("            }\n");
            } else {
                try writer.print("            if (std.json.parseFromSlice({s}, allocator, json_str, .{{}})) |parsed| {{\n", .{rel.related_type});
                try writer.print("                result.{s} = parsed.value;\n", .{rel.field_name});
                try writer.writeAll("            } else |_| {\n");
                try writer.print("                result.{s} = null;\n", .{rel.field_name});
                try writer.writeAll("            }\n");
            }
            try writer.writeAll("        } else {\n");
            try writer.print("            result.{s} = null;\n", .{rel.field_name});
            try writer.writeAll("        }\n");
        }

        try writer.writeAll("\n        return result;\n");
        try writer.writeAll("    }\n");

        try writer.writeAll("};\n");
    }

    // Clean up relation memory
    for (relations.items) |rel| {
        allocator.free(rel.field_name);
        allocator.free(rel.related_type);
        allocator.free(rel.foreign_table);
    }
}

const RelationInfo = struct {
    field_name: []const u8,
    related_type: []const u8,
    is_many: bool,
    foreign_table: []const u8,
};

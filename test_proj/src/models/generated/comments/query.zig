// AUTO-GENERATED CODE - DO NOT EDIT
// Generated by scripts/generate_model.zig
// Source schema: comments.zig
// To regenerate: zig run scripts/generate_model.zig -- comments.zig

const std = @import("std");

const pg = @import("pg");

const BaseModel = @import("../base.zig").BaseModel;
const Relationship = @import("../base.zig").Relationship;
const Executor = @import("../executor.zig").Executor;
const Posts = @import("../posts/model.zig");
const query = @import("../query.zig");
const Operator = query.Operator;
const WhereClauseType = query.WhereClauseType;
const WhereClauseInternal = query.WhereClauseInternal;
const InType = query.InType;
const JoinType = query.JoinType;
const AggregateType = query.AggregateType;
const Transaction = @import("../transaction.zig").Transaction;
const Users = @import("../users/model.zig");
const Model = @import("model.zig");
const FieldEnum = Model.FieldEnum;
const RelationEnum = Model.RelationEnum;
const IncludeClauseInput = Model.IncludeClauseInput;

// Related models
const Self = @This();

// Fields
arena: std.heap.ArenaAllocator,
select_clauses: std.ArrayList([]const u8),
where_clauses: std.ArrayList(WhereClauseInternal),
order_clauses: std.ArrayList([]const u8),
group_clauses: std.ArrayList([]const u8),
having_clauses: std.ArrayList([]const u8),
join_clauses: std.ArrayList([]const u8),
limit_val: ?u64 = null,
offset_val: ?u64 = null,
include_deleted: bool = false,
distinct_enabled: bool = false,
includes_clauses: std.ArrayList(IncludeClauseInput),
base_select_custom: bool = false,
select_raw: bool = false,
fill_base_select: bool = false,

pub const WhereClause = struct {
    field: FieldEnum,
    operator: Operator,
    value: ?[]const u8 = null,
};

pub const OrderByClause = struct {
    field: FieldEnum,
    direction: enum {
        asc,
        desc,
    },
    pub fn toSql(self: OrderByClause) []const u8 {
        return switch (self.direction) {
            .asc => "ASC",
            .desc => "DESC",
        };
    }
};

pub const SelectField = []const FieldEnum;
pub fn init() Self {
    return Self{
        .arena = std.heap.ArenaAllocator.init(std.heap.page_allocator),
        .select_clauses = std.ArrayList([]const u8){},
        .where_clauses = std.ArrayList(WhereClauseInternal){},
        .order_clauses = std.ArrayList([]const u8){},
        .group_clauses = std.ArrayList([]const u8){},
        .having_clauses = std.ArrayList([]const u8){},
        .join_clauses = std.ArrayList([]const u8){},
        .includes_clauses = std.ArrayList(IncludeClauseInput){},
    };
}

pub fn deinit(self: *Self) void {
    self.where_clauses.deinit(self.arena.allocator());
    self.select_clauses.deinit(self.arena.allocator());
    self.order_clauses.deinit(self.arena.allocator());
    self.group_clauses.deinit(self.arena.allocator());
    self.having_clauses.deinit(self.arena.allocator());
    self.join_clauses.deinit(self.arena.allocator());
    self.includes_clauses.deinit(self.arena.allocator());
    self.arena.deinit();
}

pub fn reset(self: *Self) void {
    self.select_clauses.clearAndFree(self.arena.allocator());
    self.where_clauses.clearAndFree(self.arena.allocator());
    self.order_clauses.clearAndFree(self.arena.allocator());
    self.group_clauses.clearAndFree(self.arena.allocator());
    self.having_clauses.clearAndFree(self.arena.allocator());
    self.join_clauses.clearAndFree(self.arena.allocator());
    self.includes_clauses.clearAndFree(self.arena.allocator());
    self.limit_val = null;
    self.offset_val = null;
    self.include_deleted = false;
    self.distinct_enabled = false;
    self.base_select_custom = false;
    self.select_raw = false;
    self.fill_base_select = false;
}
/// Add a SELECT clause
///
/// Example:
/// ```zig
/// .select(&.{ .id, .name })
/// ```
pub fn select(self: *Self, fields: SelectField) *Self {
    self.base_select_custom = true;
    query.select(self, fields);
    return self;
}

/// Enable DISTINCT on the query
///
/// Example:
/// ```zig
/// .distinct().select(&.{ .email })
/// ```
pub fn distinct(self: *Self) *Self {
    query.distinct(self);
    return self;
}

/// Select with an aggregate function
///
/// Example:
/// ```zig
/// .selectAggregate(.sum, .amount, "total_amount")
/// ```
pub fn selectAggregate(self: *Self, agg: AggregateType, field: FieldEnum, alias: []const u8) *Self {
    query.selectAggregate(self, agg, field, alias);
    return self;
}

/// Select raw SQL expression
///
/// Example:
/// ```zig
/// .selectRaw("COUNT(*) AS total")
/// ```
pub fn selectRaw(self: *Self, raw_sql: []const u8) *Self {
    query.selectRaw(self, raw_sql);
    self.select_raw = true;
    return self;
}

/// Add a WHERE clause. Multiple calls are ANDed together.
///
/// Example:
/// ```zig
/// .where(.{ .field = .age, .operator = .gt, .value = "$1" })
/// ```
pub fn where(self: *Self, clause: WhereClause) *Self {
    query.where(self, clause);
    return self;
}

/// Add an OR WHERE clause.
///
/// Example:
/// ```zig
/// .orWhere(.{ .field = .age, .operator = .gt, .value = "$1" })
/// ```
pub fn orWhere(self: *Self, clause: WhereClause) *Self {
    query.orWhere(self, clause);
    return self;
}

fn buildWhereClauseSql(self: *Self, clause: WhereClause) ![]const u8 {
    return query.buildWhereClauseSql(self, clause);
}

/// Add a BETWEEN clause
///
/// Example:
/// ```zig
/// .whereBetween(.age, "$1", "$2")
/// ```
pub fn whereBetween(self: *Self, field: FieldEnum, low: []const u8, high: []const u8, valueType: InType) *Self {
    query.whereBetween(self, field, low, high, valueType);
    return self;
}

/// Add a NOT BETWEEN clause
///
/// Example:
/// ```zig
/// .whereNotBetween(.age, "$1", "$2")
/// ```
pub fn whereNotBetween(self: *Self, field: FieldEnum, low: []const u8, high: []const u8, valueType: InType) *Self {
    query.whereNotBetween(self, field, low, high, valueType);
    return self;
}

/// Add a WHERE IN clause with values
///
/// Example:
/// ```zig
/// .whereIn(.status, &.{ "'active'", "'pending'" })
/// ```
pub fn whereIn(self: *Self, field: FieldEnum, values: []const []const u8, valueType: InType) *Self {
    query.whereIn(self, field, values, valueType);
    return self;
}

/// Add a WHERE NOT IN clause with values
///
/// Example:
/// ```zig
/// .whereNotIn(.status, &.{ "'deleted'", "'archived'" })
/// ```
pub fn whereNotIn(self: *Self, field: FieldEnum, values: []const []const u8, valueType: InType) *Self {
    query.whereNotIn(self, field, values, valueType);
    return self;
}

/// Add a raw WHERE clause
///
/// Example:
/// ```zig
/// .whereRaw("age > $1 AND age < $2")
/// ```
pub fn whereRaw(self: *Self, raw_sql: []const u8) *Self {
    query.whereRaw(self, raw_sql);
    return self;
}

/// Add an OR raw WHERE clause
///
/// Example:
/// ```zig
/// .orWhereRaw("status = 'vip' OR role = 'admin'")
/// ```
pub fn orWhereRaw(self: *Self, raw_sql: []const u8) *Self {
    query.orWhereRaw(self, raw_sql);
    return self;
}

/// Add a WHERE NULL clause
///
/// Example:
/// ```zig
/// .whereNull(.deleted_at)
/// ```
pub fn whereNull(self: *Self, field: FieldEnum) *Self {
    query.whereNull(self, field);
    return self;
}

/// Add a WHERE NOT NULL clause
///
/// Example:
/// ```zig
/// .whereNotNull(.email_verified_at)
/// ```
pub fn whereNotNull(self: *Self, field: FieldEnum) *Self {
    query.whereNotNull(self, field);
    return self;
}

/// Add a WHERE EXISTS subquery
///
/// Example:
/// ```zig
/// .whereExists("SELECT 1 FROM orders WHERE orders.user_id = users.id")
/// ```
pub fn whereExists(self: *Self, subquery: []const u8) *Self {
    query.whereExists(self, subquery);
    return self;
}

/// Add a WHERE NOT EXISTS subquery
///
/// Example:
/// ```zig
/// .whereNotExists("SELECT 1 FROM bans WHERE bans.user_id = users.id")
/// ```
pub fn whereNotExists(self: *Self, subquery: []const u8) *Self {
    query.whereNotExists(self, subquery);
    return self;
}

/// Add a subquery in WHERE clause
///
/// Example:
/// ```zig
/// .whereSubquery(.id, .in, "SELECT user_id FROM premium_users")
/// ```
pub fn whereSubquery(self: *Self, field: FieldEnum, operator: Operator, subquery: []const u8) *Self {
    query.whereSubquery(self, field, operator, subquery);
    return self;
}

pub fn include(self: *Self, rel: IncludeClauseInput) *Self {
    self.includes_clauses.append(self.arena.allocator(), rel);
    // build include sql using inner join
    const include_sql = try self.buildIncludeSql(rel);
    self.join_clauses.append(self.arena.allocator(), include_sql);

    return self;
}

fn buildIncludeSql(self: *Self, rel: IncludeClauseInput) ![]const u8 {
    const allocator = self.arena.allocator();
    const rel_tag = std.meta.activeTag(rel);
    const relation = Model.getRelation(rel_tag);
    const base_table = Model.tableName();

    // Default select: if user didn't specify any base select, keep base columns.
    if (self.select_clauses.items.len == 0) {
        const base_star = try std.fmt.allocPrint(allocator, "{s}.*", .{base_table});
        self.select_clauses.append(allocator, base_star) catch {};
    }

    // Build a derived-table join per include so we can apply filters without duplicating base rows.
    var select_parts = std.ArrayList([]const u8){};
    defer select_parts.deinit(allocator);

    // Always include the join key from the related table.
    const join_key = relation.foreign_key;
    const join_key_sel = try std.fmt.allocPrint(allocator, "{s}.{s}", .{ relation.foreign_table, join_key });
    try select_parts.append(allocator, join_key_sel);

    // Project requested fields.
    switch (rel) {
        .post => |cfg| {
            for (cfg.select) |field| {
                const col = @tagName(field);
                const sel = try std.fmt.allocPrint(allocator, "{s}.{s}", .{ relation.foreign_table, col });
                try select_parts.append(allocator, sel);

                const aliased = try std.fmt.allocPrint(allocator, "{s}.{s} AS post__{s}", .{ relation.foreign_table, col, col });
                self.select_clauses.append(allocator, aliased) catch {};
            }
        },
        .user => |cfg| {
            for (cfg.select) |field| {
                const col = @tagName(field);
                const sel = try std.fmt.allocPrint(allocator, "{s}.{s}", .{ relation.foreign_table, col });
                try select_parts.append(allocator, sel);

                const aliased = try std.fmt.allocPrint(allocator, "{s}.{s} AS user__{s}", .{ relation.foreign_table, col, col });
                self.select_clauses.append(allocator, aliased) catch {};
            }
        },
    }

    // WHERE conditions inside the derived table
    var where_parts = std.ArrayList([]const u8){};
    defer where_parts.deinit(allocator);

    switch (rel) {
        .post => |cfg| {
            if (!cfg.include_deleted and @hasField(Posts.PostsPartial, "deleted_at")) {
                const sd = try std.fmt.allocPrint(allocator, "{s}.deleted_at IS NULL", .{relation.foreign_table});
                try where_parts.append(allocator, sd);
            }
            for (cfg.where) |w| {
                const wsql = try buildIncludeWhere(allocator, relation.foreign_table, w);
                try where_parts.append(allocator, wsql);
            }
        },
        .user => |cfg| {
            if (!cfg.include_deleted and @hasField(Users.UsersPartial, "deleted_at")) {
                const sd = try std.fmt.allocPrint(allocator, "{s}.deleted_at IS NULL", .{relation.foreign_table});
                try where_parts.append(allocator, sd);
            }
            for (cfg.where) |w| {
                const wsql = try buildIncludeWhere(allocator, relation.foreign_table, w);
                try where_parts.append(allocator, wsql);
            }
        },
    }

    var sel_buf = std.ArrayList(u8){};
    defer sel_buf.deinit(allocator);
    for (select_parts.items, 0..) |sp, i| {
        if (i > 0) try sel_buf.appendSlice(allocator, ", ");
        try sel_buf.appendSlice(allocator, sp);
    }

    var derived = std.ArrayList(u8){};
    defer derived.deinit(allocator);
    try derived.appendSlice(allocator, "SELECT ");
    try derived.appendSlice(allocator, sel_buf.items);
    try derived.writer(allocator).print(" FROM {s}", .{relation.foreign_table});

    if (where_parts.items.len > 0) {
        try derived.appendSlice(allocator, " WHERE ");
        for (where_parts.items, 0..) |wp, i| {
            if (i > 0) try derived.appendSlice(allocator, " AND ");
            try derived.appendSlice(allocator, wp);
        }
    }

    const alias = switch (rel_tag) {
        .post => "post_inc",
        .user => "user_inc",
    };

    const on_clause = try std.fmt.allocPrint(
        allocator,
        "{s}.{s} = {s}.{s}",
        .{ base_table, relation.local_key, alias, relation.foreign_key },
    );

    return try std.fmt.allocPrint(
        allocator,
        "{s} ({s}) AS {s} ON {s}",
        .{ JoinType.inner.toSql(), derived.items, alias, on_clause },
    );
}

fn buildIncludeWhere(allocator: std.mem.Allocator, table: []const u8, clause: anytype) ![]const u8 {
    const op_str = clause.operator.toSql();

    if (clause.operator == .is_null or clause.operator == .is_not_null) {
        return try std.fmt.allocPrint(allocator, "{s}.{s} {s}", .{ table, @tagName(clause.field), op_str });
    }

    if (clause.value) |val| {
        return try std.fmt.allocPrint(allocator, "{s}.{s} {s} {s}", .{ table, @tagName(clause.field), op_str, val });
    }

    return "";
}

fn hydrateIncludes(allocator: std.mem.Allocator, row: pg.Row, item: *Model, includes: []const IncludeClauseInput) !void {
    for (includes) |rel| {
        switch (rel) {
            .post => |cfg| {
                var partial = Posts.PostsPartial{};
                var any_set = false;
                for (cfg.select) |field| {
                    const col_name = try std.fmt.allocPrint(allocator, "post__{s}", .{@tagName(field)});
                    defer allocator.free(col_name);
                    switch (field) {
                        .id => {
                            partial.id = row.getCol(?[]const u8, col_name) orelse null;
                        },
                        .title => {
                            partial.title = row.getCol(?[]const u8, col_name) orelse null;
                        },
                        .content => {
                            partial.content = row.getCol(?[]const u8, col_name) orelse null;
                        },
                        .user_id => {
                            partial.user_id = row.getCol(?[]const u8, col_name) orelse null;
                        },
                        .is_published => {
                            partial.is_published = row.getCol(?bool, col_name) orelse null;
                        },
                        .view_count => {
                            partial.view_count = row.getCol(?i32, col_name) orelse null;
                        },
                        .created_at => {
                            partial.created_at = row.getCol(?i64, col_name) orelse null;
                        },
                        .updated_at => {
                            partial.updated_at = row.getCol(?i64, col_name) orelse null;
                        },
                        .deleted_at => {
                            partial.deleted_at = row.getCol(?i64, col_name) orelse null;
                        },
                    }
                    any_set = true;
                }
                if (any_set) item.post = partial;
            },
            .user => |cfg| {
                var partial = Users.UsersPartial{};
                var any_set = false;
                for (cfg.select) |field| {
                    const col_name = try std.fmt.allocPrint(allocator, "user__{s}", .{@tagName(field)});
                    defer allocator.free(col_name);
                    switch (field) {
                        .id => {
                            partial.id = row.getCol(?[]const u8, col_name) orelse null;
                        },
                        .email => {
                            partial.email = row.getCol(?[]const u8, col_name) orelse null;
                        },
                        .name => {
                            partial.name = row.getCol(?[]const u8, col_name) orelse null;
                        },
                        .bid => {
                            partial.bid = row.getCol(?[]const u8, col_name) orelse null;
                        },
                        .password_hash => {
                            partial.password_hash = row.getCol(?[]const u8, col_name) orelse null;
                        },
                        .is_active => {
                            partial.is_active = row.getCol(?bool, col_name) orelse null;
                        },
                        .created_at => {
                            partial.created_at = row.getCol(?i64, col_name) orelse null;
                        },
                        .updated_at => {
                            partial.updated_at = row.getCol(?i64, col_name) orelse null;
                        },
                        .deleted_at => {
                            partial.deleted_at = row.getCol(?i64, col_name) orelse null;
                        },
                        .phone => {
                            partial.phone = row.getCol(?[]const u8, col_name) orelse null;
                        },
                        .bio => {
                            partial.bio = row.getCol(?[]const u8, col_name) orelse null;
                        },
                    }
                    any_set = true;
                }
                if (any_set) item.user = partial;
            },
        }
    }
}

/// Add GROUP BY clause
///
/// Example:
/// ```zig
/// .groupBy(&.{ .status, .role })
/// ```
pub fn groupBy(self: *Self, fields: []const FieldEnum) *Self {
    query.groupBy(self, fields);
    return self;
}

/// Add GROUP BY with raw SQL
///
/// Example:
/// ```zig
/// .groupByRaw("DATE(created_at)")
/// ```
pub fn groupByRaw(self: *Self, raw_sql: []const u8) *Self {
    query.groupByRaw(self, raw_sql);
    return self;
}

/// Add HAVING clause
///
/// Example:
/// ```zig
/// .having("COUNT(*) > $1")
/// ```
pub fn having(self: *Self, condition: []const u8) *Self {
    query.having(self, condition);
    return self;
}

/// Add HAVING with aggregate function
///
/// Example:
/// ```zig
/// .havingAggregate(.count, .id, .gt, "$1")
/// ```
pub fn havingAggregate(self: *Self, agg: AggregateType, field: FieldEnum, operator: Operator, value: []const u8) *Self {
    query.havingAggregate(self, agg, field, operator, value);
    return self;
}

/// Set ORDER BY clause (can be called multiple times)
///
/// Example:
/// ```zig
/// .orderBy(.{ .field = .created_at, .direction = .desc })
/// .orderBy(.{ .field = .name, .direction = .asc })
/// ```
pub fn orderBy(self: *Self, clause: OrderByClause) *Self {
    query.orderBy(self, clause);
    return self;
}

/// Add raw ORDER BY clause
///
/// Example:
/// ```zig
/// .orderByRaw("RANDOM()")
/// ```
pub fn orderByRaw(self: *Self, raw_sql: []const u8) *Self {
    query.orderByRaw(self, raw_sql);
    return self;
}

/// Set LIMIT
///
/// Example:
/// ```zig
/// .limit(10)
/// ```
pub fn limit(self: *Self, n: u64) *Self {
    query.limit(self, n);
    return self;
}

/// Set OFFSET
///
/// Example:
/// ```zig
/// .offset(10)
/// ```
pub fn offset(self: *Self, n: u64) *Self {
    query.offset(self, n);
    return self;
}

/// Paginate results (convenience method for limit + offset)
///
/// Example:
/// ```zig
/// .paginate(2, 20) // Page 2 with 20 items per page
/// ```
pub fn paginate(self: *Self, page: u64, per_page: u64) *Self {
    query.paginate(self, page, per_page);
    return self;
}

/// Include soft-deleted records
pub fn withDeleted(self: *Self) *Self {
    query.withDeleted(self);
    return self;
}

/// Only get soft-deleted records
///
/// Example:
/// ```zig
/// .onlyDeleted()
/// ```
pub fn onlyDeleted(self: *Self) *Self {
    query.onlyDeleted(self);
    return self;
}

pub fn buildSql(self: *Self, allocator: std.mem.Allocator) ![]const u8 {
    var sql = std.ArrayList(u8){};
    defer sql.deinit(allocator);

    const table_name = Model.tableName();

    // Ensure base model columns are present when user customized select
    if (self.base_select_custom and self.fill_base_select) {
        try ensureBaseSelects(self, allocator);
    }

    // SELECT clause
    if (self.distinct_enabled) {
        try sql.appendSlice(allocator, "SELECT DISTINCT ");
    } else {
        try sql.appendSlice(allocator, "SELECT ");
    }

    if (self.select_clauses.items.len > 0) {
        for (self.select_clauses.items, 0..) |clause, i| {
            try sql.appendSlice(allocator, clause);
            if (i < self.select_clauses.items.len - 1) {
                try sql.appendSlice(allocator, ", ");
            }
        }
        try sql.appendSlice(allocator, " ");
    } else {
        try sql.appendSlice(allocator, "* ");
    }

    // FROM clause
    try sql.writer(allocator).print("FROM {s}", .{table_name});

    // JOIN clauses
    for (self.join_clauses.items) |join_sql| {
        try sql.appendSlice(allocator, " ");
        try sql.appendSlice(allocator, join_sql);
    }

    var first_where = true;

    // Handle soft deletes
    const has_deleted_at = @hasField(Model, "deleted_at");
    if (has_deleted_at and !self.include_deleted) {
        try sql.appendSlice(allocator, " WHERE deleted_at IS NULL");
        first_where = false;
    }

    // WHERE clauses
    for (self.where_clauses.items) |clause| {
        if (first_where) {
            try sql.appendSlice(allocator, " WHERE ");
            first_where = false;
        } else {
            try sql.writer(allocator).print(" {s} ", .{clause.clause_type.toSql()});
        }
        try sql.appendSlice(allocator, clause.sql);
    }

    // GROUP BY clause
    if (self.group_clauses.items.len > 0) {
        try sql.appendSlice(allocator, " GROUP BY ");
        for (self.group_clauses.items, 0..) |group, i| {
            try sql.appendSlice(allocator, group);
            if (i < self.group_clauses.items.len - 1) {
                try sql.appendSlice(allocator, ", ");
            }
        }
    }

    // HAVING clause
    if (self.having_clauses.items.len > 0) {
        try sql.appendSlice(allocator, " HAVING ");
        for (self.having_clauses.items, 0..) |having_clause, i| {
            try sql.appendSlice(allocator, having_clause);
            if (i < self.having_clauses.items.len - 1) {
                try sql.appendSlice(allocator, " AND ");
            }
        }
    }

    // ORDER BY clause
    if (self.order_clauses.items.len > 0) {
        try sql.appendSlice(allocator, " ORDER BY ");
        for (self.order_clauses.items, 0..) |order, i| {
            try sql.appendSlice(allocator, order);
            if (i < self.order_clauses.items.len - 1) {
                try sql.appendSlice(allocator, ", ");
            }
        }
    }

    // LIMIT clause
    if (self.limit_val) |l| {
        var buf: [32]u8 = undefined;
        const _limit = try std.fmt.bufPrint(&buf, " LIMIT {d}", .{l});
        try sql.appendSlice(allocator, _limit);
    }

    // OFFSET clause
    if (self.offset_val) |o| {
        var buf: [32]u8 = undefined;
        const _offset = try std.fmt.bufPrint(&buf, " OFFSET {d}", .{o});
        try sql.appendSlice(allocator, _offset);
    }

    return sql.toOwnedSlice(allocator);
}

fn ensureBaseSelects(self: *Self, allocator: std.mem.Allocator) !void {
    // Gather existing base selections (non-include aliases)
    var present = std.AutoHashMap([]const u8, void).init(allocator);
    defer present.deinit();

    var base_entries = std.ArrayList([]const u8){};
    defer base_entries.deinit(allocator);

    for (self.select_clauses.items) |sel| {
        // Skip include aliases (post__/user__)
        if (std.mem.indexOf(u8, sel, "post__") != null or std.mem.indexOf(u8, sel, "user__") != null) {
            continue;
        }
        // Normalize: strip table prefix if present
        const dot = std.mem.indexOf(u8, sel, ".");
        const key = if (dot) |idx| sel[idx + 1 ..] else sel;
        present.put(key, {}) catch {};
        base_entries.append(sel) catch {};
    }

    inline for (@typeInfo(FieldEnum).Enum.fields) |f| {
        const fname = f.name;
        if (!present.contains(fname)) {
            const full = try std.fmt.allocPrint(allocator, "{s}.{s}", .{ Model.tableName(), fname });
            self.select_clauses.append(allocator, full) catch {};
        }
    }
}

/// Check if the query has custom projections that can't be mapped to the model type.
/// This includes:
/// - Aggregate functions (COUNT, SUM, etc.)
/// - Raw selects with aliases (AS)
/// - JOIN clauses (result columns from multiple tables)
/// - GROUP BY clauses (typically used with aggregates)
/// - HAVING clauses (requires GROUP BY)
/// - DISTINCT with custom selects
fn hasCustomProjection(self: *Self) bool {
    // Allow include joins/selects; still flag group/having and raw selects
    if (self.group_clauses.items.len > 0 or self.having_clauses.items.len > 0) return true;

    // Treat explicit raw selects as custom
    if (self.select_raw) return true;

    return false;
}

/// Execute query and return list of items.
/// Returns an error if the query contains custom projections that can't map to model type K:
/// - JOINs (use `FieldEnumtchRaw` or `FieldEnumtchAs` with a custom struct)
/// - GROUP BY / HAVING clauses
/// - Aggregate functions (selectAggregate)
/// - Raw selects with aliases or table prefixes
///
/// Example:
/// ```zig
/// const users = try User.query()
///     .where(.{ .field = .status, .operator = .eq, .value = "'active'" })
///     .fetch(&pool, allocator, .{});
/// defer allocator.free(users);
/// ```
pub fn fetch(self: *Self, db: Executor, allocator: std.mem.Allocator, args: anytype) ![]Model {
    if (self.hasCustomProjection()) {
        return error.CustomProjectionNotSupported;
    }

    self.fill_base_select = true; // ensure base selects are included

    const temp_allocator = self.arena.allocator();
    const sql = try self.buildSql(temp_allocator);

    var result = try db.queryOpts(sql, args, .{
        .column_names = true,
    });
    defer result.deinit();

    var items = std.ArrayList(Model){};
    defer items.deinit(allocator);

    while (try result.next()) |row| {
        var item = try row.to(Model, .{ .allocator = allocator, .map = .name });
        if (self.includes_clauses.items.len > 0) {
            try hydrateIncludes(allocator, row, &item, self.includes_clauses.items);
        }
        try items.append(allocator, item);
    }

    return items.toOwnedSlice(allocator);
}

/// Execute query and return list of partials (optional fields) of the model.
pub fn fetchPartial(self: *Self, db: Executor, allocator: std.mem.Allocator, args: anytype) ![]Model.CommentsPartial {
    if (self.hasCustomProjection()) {
        return error.CustomProjectionNotSupported;
    }

    self.fill_base_select = false; // do not enforce base selects for partials

    const temp_allocator = self.arena.allocator();
    const sql = try self.buildSql(temp_allocator);

    var result = try db.queryOpts(sql, args, .{
        .column_names = true,
    });
    defer result.deinit();

    var items = std.ArrayList(Model.CommentsPartial){};
    defer items.deinit(allocator);

    while (try result.next()) |row| {
        const partial = try row.to(Model.CommentsPartial, .{ .allocator = allocator, .map = .name });
        if (self.includes_clauses.items.len > 0) {
            try hydrateIncludes(allocator, row, &partial, self.includes_clauses.items);
        }
        try items.append(allocator, partial);
    }

    return items.toOwnedSlice(allocator);
}

/// Execute query and return list of items mapped to a custom result type.
/// Use this when you have custom selects, aggregates, or need a difFieldEnumrent shape than the model.
///
/// Example:
/// ```zig
/// const UserSummary = struct { id: i64, total_posts: i64 };
/// const summaries = try User.query()
///     .select(&.{.id})
///     .selectAggregate(.count, .id, "total_posts")
///     .groupBy(&.{.id})
///     .fetchAs(UserSummary, &pool, allocator, .{});
/// defer allocator.free(summaries);
/// ```
pub fn fetchAs(self: *Self, comptime R: type, db: Executor, allocator: std.mem.Allocator, args: anytype) ![]R {
    return query.fetchAs(self, R, db, allocator, args);
}

/// Execute query and return the raw pg.Result.
/// Use this for complex queries with joins, subqueries, or when you need full control.
/// The caller is responsible for calling result.deinit() when done.
///
/// Example:
/// ```zig
/// var result = try User.query()
///     .innerJoin("posts", "users.id = posts.user_id")
///     .selectRaw("users.*, posts.title")
///     .fetchRaw(&pool, .{});
/// defer result.deinit();
///
/// while (try result.next()) |row| {
///     const user_id = row.get(i64, 0);
///     const post_title = row.get([]const u8, 1);
///     // ...
/// }
/// ```
pub fn fetchRaw(self: *Self, db: Executor, args: anytype) !pg.Result {
    return query.fetchRaw(self, db, args);
}

/// Execute query and return first item or null.
/// Returns an error if the query contains custom projections (JOINs, GROUP BY, aggregates, etc.).
/// Use `firstAs` for custom result types or `firstRaw` for direct access.
pub fn first(self: *Self, db: Executor, allocator: std.mem.Allocator, args: anytype) !?Model {
    if (self.hasCustomProjection()) {
        return error.CustomProjectionNotSupported;
    }

    self.fill_base_select = true; // ensure base selects are included

    self.limit_val = 1;
    const temp_allocator = self.arena.allocator();
    const sql = try self.buildSql(temp_allocator);

    var result = try db.queryOpts(sql, args, .{
        .column_names = true,
    });
    defer result.deinit();

    if (try result.next()) |row| {
        var item = try row.to(Model, .{ .allocator = allocator, .map = .name });
        if (self.includes_clauses.items.len > 0) {
            try hydrateIncludes(allocator, row, &item, self.includes_clauses.items);
        }
        return item;
    }
    return null;
}

/// Execute query and return first partial or null.
pub fn firstPartial(self: *Self, db: Executor, allocator: std.mem.Allocator, args: anytype) !?Model.CommentsPartial {
    if (self.hasCustomProjection()) {
        return error.CustomProjectionNotSupported;
    }
    self.limit_val = 1;
    const temp_allocator = self.arena.allocator();
    const sql = try self.buildSql(temp_allocator);

    var result = try db.queryOpts(sql, args, .{
        .column_names = true,
    });
    defer result.deinit();

    if (try result.next()) |row| {
        var partial = try row.to(Model.CommentsPartial, .{ .allocator = allocator, .map = .name });
        if (self.includes_clauses.items.len > 0) {
            try hydrateIncludes(allocator, row, &partial, self.includes_clauses.items);
        }
        return partial;
    }
    return null;
}

/// Execute query and return first item mapped to a custom result type, or null.
///
/// Example:
/// ```zig
/// const UserStats = struct { id: i64, post_count: i64 };
/// const stats = try User.query()
///     .select(&.{.id})
///     .selectAggregate(.count, .id, "post_count")
///     .where(.{ .field = .id, .operator = .eq, .value = "$1" })
///     .firstAs(UserStats, &pool, allocator, .{user_id});
/// ```
pub fn firstAs(self: *Self, comptime R: type, db: Executor, allocator: std.mem.Allocator, args: anytype) !?R {
    return query.firstAs(self, R, db, allocator, args);
}

/// Execute query and return first row as pg.QueryRow or null.
/// The caller is responsible for calling row.deinit() when done.
///
/// Example:
/// ```zig
/// if (try User.query()
///     .selectRaw("users.*, COUNT(posts.id) as post_count")
///     .innerJoin("posts", "users.id = posts.user_id")
///     .firstRaw(&pool, .{})) |row|
/// {
///     defer row.deinit();
///     const name = row.get([]const u8, 1);
///     const post_count = row.get(i64, 2);
/// }
/// ```
pub fn firstRaw(self: *Self, db: Executor, args: anytype) !?pg.Result {
    return query.firstRaw(self, db, args);
}

/// Delete a record
pub fn delete(self: *Self, db: Executor, args: anytype) !void {
    return query.delete(self, db, args, Model);
}

/// Count records matching the query
pub fn count(self: *Self, db: Executor, args: anytype) !i64 {
    return query.count(self, db, args, Model);
}

/// Check if any records match the query
///
/// Example:
/// ```zig
/// const has_users = try User.query()
///     .where(.{ .field = .status, .operator = .eq, .value = "'active'" })
///     .exists(&pool);
/// ```
pub fn exists(self: *Self, db: Executor, args: anytype) !bool {
    return query.exists(self, db, args, Model);
}

/// Get a single column as a slice
/// !NOT working for non string field
///
/// Example:
/// ```zig
/// const emails = try User.query().pluck(&pool, allocator, .email, .{});
/// ```
pub fn pluck(self: *Self, db: Executor, allocator: std.mem.Allocator, field: FieldEnum, args: anytype) ![][]const u8 {
    return query.pluck(self, db, allocator, field, args, Model);
}

/// Get the sum of a column
///
/// Example:
/// ```zig
/// const total = try Order.query().sum(&pool, .amount, .{});
/// ```
pub fn sum(self: *Self, db: Executor, field: FieldEnum, args: anytype) !f64 {
    return self.aggregate(db, .sum, field, args);
}

/// Get the average of a column
///
/// Example:
/// ```zig
/// const avg_rating = try Review.query().avg(&pool, .rating, .{});
/// ```
pub fn avg(self: *Self, db: Executor, field: FieldEnum, args: anytype) !f64 {
    return self.aggregate(db, .avg, field, args);
}

/// Get the minimum value of a column
///
/// Example:
/// ```zig
/// const min_price = try Product.query().min(&pool, .price, .{});
/// ```
pub fn min(self: *Self, db: Executor, field: FieldEnum, args: anytype) !f64 {
    return self.aggregate(db, .min, field, args);
}

/// Get the maximum value of a column
///
/// Example:
/// ```zig
/// const max_price = try Product.query().max(&pool, .price, .{});
/// ```
pub fn max(self: *Self, db: Executor, field: FieldEnum, args: anytype) !f64 {
    return self.aggregate(db, .max, field, args);
}

fn aggregate(self: *Self, db: Executor, agg: AggregateType, field: FieldEnum, args: anytype) !f64 {
    return query.aggregate(self, db, agg, field, args, Model);
}

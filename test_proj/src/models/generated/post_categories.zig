// AUTO-GENERATED CODE - DO NOT EDIT
// Generated by scripts/generate_model.zig
// Source schema: post_categories.zig
// To regenerate: zig run scripts/generate_model.zig -- post_categories.zig

const std = @import("std");
const pg = @import("pg");
const BaseModel = @import("base.zig").BaseModel;
const Executor = @import("executor.zig").Executor;
const includeQuery = @import("includeQuery.zig");
const QueryBuilder = @import("query.zig").QueryBuilder;
const Transaction = @import("transaction.zig").Transaction;

// Related models
const Categories = @import("categories.zig");
const Posts = @import("posts.zig");

const PostCategories = @This();

// Fields
id: []const u8,
post_id: []const u8,
category_id: []const u8,
created_at: i64,
    pub const FieldEnum = enum {
        id,
        post_id,
        category_id,
        created_at,
    };


    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        allocator.free(self.id);
        allocator.free(self.post_id);
        allocator.free(self.category_id);
    }

    // Input type for creating new records
    pub const CreateInput = struct {
        post_id: []const u8,
        category_id: []const u8,
    };

    // Input type for updating existing records
    pub const UpdateInput = struct {
        post_id: ?[]const u8 = null,
        category_id: ?[]const u8 = null,
    };

    // Model configuration
    pub fn tableName() []const u8 {
        return "post_categories";
    }

    pub fn insertSQL() []const u8 {
        return
            \\INSERT INTO post_categories (
            \\    post_id, category_id
            \\) VALUES ($1, $2)
            \\RETURNING id
        ;
    }

    pub fn insertParams(data: CreateInput) struct {
        []const u8,
        []const u8,
    } {
        return .{
            data.post_id,
            data.category_id,
        };
    }

    pub fn updateSQL() []const u8 {
        return
            \\UPDATE post_categories SET
            \\    post_id = COALESCE($2, post_id),
            \\    category_id = COALESCE($3, category_id)
            \\WHERE id = $1
        ;
    }

    pub fn updateParams(id: []const u8, data: UpdateInput) struct {
        []const u8,
        ?[]const u8,
        ?[]const u8,
    } {
        return .{
            id,
            data.post_id,
            data.category_id,
        };
    }

    const base = BaseModel(PostCategories);
    // DDL operations

    pub const truncate = base.truncate;

    pub const tableExists = base.tableExists;

    // CRUD operations
    pub const findById = base.findById;

    pub const findAll = base.findAll;

    pub const insert = base.insert;

    pub const insertMany = base.insertMany;

    pub const insertAndReturn = base.insertAndReturn;

    pub const update = base.update;

    pub const updateAndReturn = base.updateAndReturn;

    pub const softDelete = base.softDelete;

    pub const hardDelete = base.hardDelete;

    pub const count = base.count;

    pub const fromRow = base.fromRow;

    pub fn query() QueryBuilder(PostCategories, UpdateInput, FieldEnum) {
        return QueryBuilder(PostCategories, UpdateInput, FieldEnum).init();
    }


    /// JSON-safe response struct with UUIDs as hex strings
    pub const JsonResponse = struct {
        id: [36]u8,
        post_id: [36]u8,
        category_id: [36]u8,
        created_at: i64,
    };

    /// Convert model to JSON-safe response with UUIDs as hex strings
    pub fn toJsonResponse(self: PostCategories) !JsonResponse {
        return JsonResponse{
            .id = try pg.uuidToHex(&self.id[0..16].*),
            .post_id = try pg.uuidToHex(&self.post_id[0..16].*),
            .category_id = try pg.uuidToHex(&self.category_id[0..16].*),
            .created_at = self.created_at,
        };
    }

    /// JSON-safe response struct with UUIDs as hex strings (excludes redacted fields)
    pub const JsonResponseSafe = struct {
        id: [36]u8,
        post_id: [36]u8,
        category_id: [36]u8,
        created_at: i64,
    };

    /// Convert model to JSON-safe response excluding redacted fields (passwords, tokens, etc.)
    pub fn toJsonResponseSafe(self: PostCategories) !JsonResponseSafe {
        return JsonResponseSafe{
            .id = try pg.uuidToHex(&self.id[0..16].*),
            .post_id = try pg.uuidToHex(&self.post_id[0..16].*),
            .category_id = try pg.uuidToHex(&self.category_id[0..16].*),
            .created_at = self.created_at,
        };
    }
    // Relationship methods
    /// Fetch the related Posts record for this PostCategories
    pub fn fetchPost(self: *const PostCategories, db: *pg.Pool, allocator: std.mem.Allocator) !?Posts {
        return Posts.findById(db, allocator, self.post_id);
    }

    /// Fetch the related Categories record for this PostCategories
    pub fn fetchCategory(self: *const PostCategories, db: *pg.Pool, allocator: std.mem.Allocator) !?Categories {
        return Categories.findById(db, allocator, self.category_id);
    }


    // Relationship metadata for include queries
    pub const rel_post = includeQuery.RelationMeta{
        .name = "post",
        .table = "posts",
        .foreign_key = "post_id",
        .local_key = "id",
        .relation_type = .belongs_to,
    };
    pub const rel_category = includeQuery.RelationMeta{
        .name = "category",
        .table = "categories",
        .foreign_key = "category_id",
        .local_key = "id",
        .relation_type = .belongs_to,
    };
    // Transaction support (use generic Transaction from transaction.zig)
    // Example:
    //   var tx = try Transaction.begin(pool);
    //   defer tx.deinit();
    //   const id = try @This().insert(tx.executor(), allocator, data);
    //   try tx.commit();

// AUTO-GENERATED CODE - DO NOT EDIT
// Generated by scripts/generate_model.zig
// Source schema: organization_users.zig
// To regenerate: zig run scripts/generate_model.zig -- organization_users.zig

const std = @import("std");
const pg = @import("pg");
const BaseModel = @import("../base.zig").BaseModel;
const Query = @import("query.zig");
const Relationship = @import("../base.zig").Relationship;
const Tables = @import("../registry.zig").Tables;
const Executor = @import("../executor.zig").Executor;
const err = @import("../error.zig");
const OrmError = err.OrmError;

// Related models
const Organizations = @import("../organizations/model.zig");
const OrganizationsQuery = @import("../organizations/query.zig");
const Uwsers = @import("../uwsers/model.zig");
const UwsersQuery = @import("../uwsers/query.zig");

const OrganizationUsers = @This();

// Fields
    id: []const u8,
    organization_id: []const u8,
    user_id: []const u8,
    status: []const u8,
    role: []const u8,
    created_at: i64,
    updated_at: i64,
    deleted_at: ?i64,
    pub const FieldEnum = enum {
        id,
        organization_id,
        user_id,
        status,
        role,
        created_at,
        updated_at,
        deleted_at,

        pub fn isDateTime(self: @This()) bool {
            return switch (self) {
                .created_at => true,
                .updated_at => true,
                .deleted_at => true,
                else => false,
            };
        }
    };
    pub const RelationEnum = enum {
        organization,
        user,
    };

    pub fn getRelation(rel: RelationEnum) Relationship {
        return switch (rel) {
            .organization => .{ .name = "organization", .type = .belongsTo, .foreign_table = .organizations, .foreign_key = .{ .organizations = .id }, .local_key = .{ .organization_users = .organization_id } },
            .user => .{ .name = "user", .type = .belongsTo, .foreign_table = .uwsers, .foreign_key = .{ .uwsers = .id }, .local_key = .{ .organization_users = .user_id } },
        };
    }

    pub const OrganizationsIncludeClauseInput = struct {
        model_name: RelationEnum,
        select: []const Organizations.FieldEnum = &.{},
        where: []const OrganizationsQuery.WhereClause = &.{},
    };

    pub const UwsersIncludeClauseInput = struct {
        model_name: RelationEnum,
        select: []const Uwsers.FieldEnum = &.{},
        where: []const UwsersQuery.WhereClause = &.{},
    };

    pub const IncludeClauseInput = union(RelationEnum) {
        organization: OrganizationsIncludeClauseInput,
        user: UwsersIncludeClauseInput,
    };

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        allocator.free(self.id);
        allocator.free(self.organization_id);
        allocator.free(self.user_id);
        allocator.free(self.status);
        allocator.free(self.role);
    }

    // Input type for creating new records
    pub const CreateInput = struct {
        organization_id: []const u8,
        user_id: []const u8,
        status: []const u8,
        role: []const u8,
    };

    // Input type for updating existing records
    pub const UpdateInput = struct {
        organization_id: ?[]const u8 = null,
        user_id: ?[]const u8 = null,
        status: ?[]const u8 = null,
        role: ?[]const u8 = null,
    };

    // Model configuration
    pub fn tableName() []const u8 {
        return "organization_users";
    }

    pub const json_all_fields_sql = "jsonb_build_object('id', id, 'organization_id', organization_id, 'user_id', user_id, 'status', status, 'role', role, 'created_at', (extract(epoch from created_at) * 1000000)::bigint, 'updated_at', (extract(epoch from updated_at) * 1000000)::bigint, 'deleted_at', (extract(epoch from deleted_at) * 1000000)::bigint)";

    pub fn insertSQL() []const u8 {
        return
            \\INSERT INTO organization_users (
            \\    organization_id, user_id, status, role
            \\) VALUES ($1, $2, $3, $4)
            \\RETURNING id
        ;
    }

    pub fn insertParams(data: CreateInput) struct {
        []const u8,
        []const u8,
        []const u8,
        []const u8,
    } {
        return .{
            data.organization_id,
            data.user_id,
            data.status,
            data.role,
        };
    }

    pub fn updateSQL() []const u8 {
        return
            \\UPDATE organization_users SET
            \\    organization_id = COALESCE($2, organization_id),
            \\    user_id = COALESCE($3, user_id),
            \\    status = COALESCE($4, status),
            \\    role = COALESCE($5, role),
            \\    updated_at =  CURRENT_TIMESTAMP
            \\WHERE id = $1
        ;
    }

    pub fn updateParams(id: []const u8, data: UpdateInput) struct {
        []const u8,
        ?[]const u8,
        ?[]const u8,
        ?[]const u8,
        ?[]const u8,
    } {
        return .{
            id,
            data.organization_id,
            data.user_id,
            data.status,
            data.role,
        };
    }

    const base = BaseModel(OrganizationUsers);
    // DDL operations

    pub const truncate = base.truncate;

    pub const tableExists = base.tableExists;

    // CRUD operations
    pub const findById = base.findById;

    pub const findAll = base.findAll;

    pub const insert = base.insert;

    pub const insertMany = base.insertMany;

    pub const insertAndReturn = base.insertAndReturn;

    pub const update = base.update;

    pub const updateAndReturn = base.updateAndReturn;

    pub const softDelete = base.softDelete;

    pub const hardDelete = base.hardDelete;

    pub const count = base.count;

    pub const fromRow = base.fromRow;

    pub const query = Query.init;

    pub const queryWithArena = Query.initWithArena;

    pub const queryWithAllocator = Query.initWithAllocator;


    /// JSON-safe response struct with UUIDs as hex strings
    pub const JsonResponse = struct {
        id: [36]u8,
        organization_id: [36]u8,
        user_id: [36]u8,
        status: []const u8,
        role: []const u8,
        created_at: i64,
        updated_at: i64,
        deleted_at: ?i64,
    };

    /// Convert model to JSON-safe response with UUIDs as hex strings
    pub fn toJsonResponse(self: OrganizationUsers) !JsonResponse {
        return JsonResponse{
            .id = try pg.uuidToHex(&self.id[0..16].*),
            .organization_id = try pg.uuidToHex(&self.organization_id[0..16].*),
            .user_id = try pg.uuidToHex(&self.user_id[0..16].*),
            .status = self.status,
            .role = self.role,
            .created_at = self.created_at,
            .updated_at = self.updated_at,
            .deleted_at = self.deleted_at,
        };
    }

    /// JSON-safe response struct with UUIDs as hex strings (excludes redacted fields)
    pub const JsonResponseSafe = struct {
        id: [36]u8,
        organization_id: [36]u8,
        user_id: [36]u8,
        status: []const u8,
        role: []const u8,
        created_at: i64,
        updated_at: i64,
        deleted_at: ?i64,
    };

    /// Convert model to JSON-safe response excluding redacted fields (passwords, tokens, etc.)
    pub fn toJsonResponseSafe(self: OrganizationUsers) !JsonResponseSafe {
        return JsonResponseSafe{
            .id = try pg.uuidToHex(&self.id[0..16].*),
            .organization_id = try pg.uuidToHex(&self.organization_id[0..16].*),
            .user_id = try pg.uuidToHex(&self.user_id[0..16].*),
            .status = self.status,
            .role = self.role,
            .created_at = self.created_at,
            .updated_at = self.updated_at,
            .deleted_at = self.deleted_at,
        };
    }
    // Relationship methods
    /// Fetch the related Organizations record for this OrganizationUsers
    pub fn fetchOrganization(self: *const OrganizationUsers, db: Executor, allocator: std.mem.Allocator) err.Result(?Organizations) {
        return Organizations.findById(db, allocator, self.organization_id);
    }

    /// Fetch the related Uwsers record for this OrganizationUsers
    pub fn fetchUser(self: *const OrganizationUsers, db: Executor, allocator: std.mem.Allocator) err.Result(?Uwsers) {
        return Uwsers.findById(db, allocator, self.user_id);
    }


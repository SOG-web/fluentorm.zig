// AUTO-GENERATED CODE - DO NOT EDIT
// Generated by scripts/generate_model.zig
// Source schema: categories.zig
// To regenerate: zig run scripts/generate_model.zig -- categories.zig

const std = @import("std");
const pg = @import("pg");
const BaseModel = @import("../base.zig").BaseModel;
const Executor = @import("../executor.zig").Executor;
const query = @import("../query.zig");
const JoinClause = query.JoinClause;
const WhereValue = query.WhereValue;
const IncludeClauseInput = Model.IncludeClauseInput;
const Operator = query.Operator;
const WhereClauseType = query.WhereClauseType;
const WhereClauseInternal = query.WhereClauseInternal;
const InType = query.InType;
const JoinType = query.JoinType;
const AggregateType = query.AggregateType;
const Model = @import("model.zig");
const FieldEnum = Model.FieldEnum;
const RelationEnum = Model.RelationEnum;
const Transaction = @import("../transaction.zig").Transaction;
const Relationship = @import("../base.zig").Relationship;

// Related models
const PostCategories = @import("../post_categories/model.zig");

const Self = @This();

// Fields
 arena: std.heap.ArenaAllocator,
 select_clauses: std.ArrayList([]const u8),
 where_clauses: std.ArrayList(WhereClauseInternal),
 order_clauses: std.ArrayList([]const u8),
 group_clauses: std.ArrayList([]const u8),
 having_clauses: std.ArrayList([]const u8),
 join_clauses: std.ArrayList(JoinClause),
 limit_val: ?u64 = null,
 offset_val: ?u64 = null,
 include_deleted: bool = false,
 distinct_enabled: bool = false,
 includes_clauses: std.ArrayList(Model.IncludeClauseInput),
 base_select_custom: bool = false,
 select_raw: bool = false,
 fill_base_select: bool = false,

  pub const WhereClause = struct {
      where_type: WhereClauseType = .@"and",
      field: FieldEnum,
      operator: Operator,
      value: ?WhereValue = null,
   };


 pub const OrderByClause = struct {
      field: FieldEnum,
      direction: enum {
         asc,
         desc,
      },
     pub fn toSql(self: OrderByClause) []const u8 {
         return switch (self.direction) {
            .asc => "ASC",
            .desc => "DESC",
         };
      }
   };

   pub const SelectField = []const FieldEnum;
 /// Comptime constant for table name (optimization)
 pub const table_name = Model.table_name;

 /// Returns the table name (uses comptime constant for optimization)
 pub fn tablename(_: *Self) []const u8 {
    return table_name;
 }

 /// Create a new query builder using page_allocator for its arena.
 pub fn init() Self {
    return initWithAllocator(std.heap.page_allocator);
 }

 /// Create a query builder with a custom backing allocator for its arena.
 pub fn initWithAllocator(backing_allocator: std.mem.Allocator) Self {
    return Self{
       .arena = std.heap.ArenaAllocator.init(backing_allocator),
       .select_clauses = std.ArrayList([]const u8){},
       .where_clauses = std.ArrayList(WhereClauseInternal){},
       .order_clauses = std.ArrayList([]const u8){},
       .group_clauses = std.ArrayList([]const u8){},
       .having_clauses = std.ArrayList([]const u8){},
       .join_clauses = std.ArrayList(JoinClause){},
       .includes_clauses = std.ArrayList(Model.IncludeClauseInput){},
       .base_select_custom = false,
       .select_raw = false,
       .fill_base_select = false,
    };
 }

 /// Create a query builder using an existing ArenaAllocator.
 /// Ideal for http.zig request handlers where the arena is managed externally.
 pub fn initWithArena(arena_allocator: std.heap.ArenaAllocator) Self {
    return Self{
       .arena = arena_allocator,
       .select_clauses = std.ArrayList([]const u8){},
       .where_clauses = std.ArrayList(WhereClauseInternal){},
       .order_clauses = std.ArrayList([]const u8){},
       .group_clauses = std.ArrayList([]const u8){},
       .having_clauses = std.ArrayList([]const u8){},
       .join_clauses = std.ArrayList(JoinClause){},
       .includes_clauses = std.ArrayList(Model.IncludeClauseInput){},
       .base_select_custom = false,
       .select_raw = false,
       .fill_base_select = false,
    };
 }

 pub fn deinit(self: *Self) void {
    self.where_clauses.deinit(self.arena.allocator());
    self.select_clauses.deinit(self.arena.allocator());
    self.order_clauses.deinit(self.arena.allocator());
    self.group_clauses.deinit(self.arena.allocator());
    self.having_clauses.deinit(self.arena.allocator());
    self.join_clauses.deinit(self.arena.allocator());
    self.includes_clauses.deinit(self.arena.allocator());
    self.arena.deinit();
 }

 pub fn reset(self: *Self) void {
    self.select_clauses.clearAndFree(self.arena.allocator());
    self.where_clauses.clearAndFree(self.arena.allocator());
    self.order_clauses.clearAndFree(self.arena.allocator());
    self.group_clauses.clearAndFree(self.arena.allocator());
    self.having_clauses.clearAndFree(self.arena.allocator());
    self.join_clauses.clearAndFree(self.arena.allocator());
    self.includes_clauses.clearAndFree(self.arena.allocator());
    self.limit_val = null;
    self.offset_val = null;
    self.include_deleted = false;
    self.distinct_enabled = false;
    self.base_select_custom = false;
    self.select_raw = false;
    self.fill_base_select = false;
 }
    pub fn buildIncludeSql(self: *Self, rel: IncludeClauseInput) !JoinClause {
        const rel_tag = std.meta.activeTag(rel);
        const relation = Model.getRelation(rel_tag);

        var clause = JoinClause{
            .join_type = JoinType.left,
            .join_table = relation.foreign_table,
            .join_field = relation.foreign_key,
            .join_operator = .eq,
            .base_field = relation.local_key,
            .predicates = &.{},
            .select = &.{"*"},
        };

        switch (rel) {            .posts => |r| {
                // Construct the where clause from rel into an sql string
                if (r.where.len > 0) {
                    clause.predicates = try self.arena.allocator().alloc(query.PredicateClause, r.where.len);
                    for (r.where, 0..) |cl, i| {
                        const str = try query.buildIncludeWhere(self, cl, @tagName(relation.foreign_table), cl.value);
                        clause.predicates[i] = .{
                            .where_type = cl.where_type,
                            .sql = str,
                        };
                    }
                }

                // Construct select clause
                if (r.select.len > 0) {
                    const selects = try self.arena.allocator().alloc([]const u8, r.select.len);
                    for (r.select, 0..) |field, i| {
                        selects[i] = @tagName(field);
                    }
                    clause.select = selects;
                }
            },
        }
        return clause;
    }
/// Add a SELECT clause
///
/// Example:
/// ```zig
/// .select(&.{ .id, .name })
/// ```
pub fn select(self: *Self, comptime fields: SelectField) *Self {
    self.base_select_custom = true;
    query.select(self, fields);
    return self;
}

/// Enable DISTINCT on the query
///
/// Example:
/// ```zig
/// .distinct().select(&.{ .email })
/// ```
pub fn distinct(self: *Self) *Self {
    query.distinct(self);
    return self;
}

/// Select with an aggregate function
///
/// Example:
/// ```zig
/// .selectAggregate(.sum, .amount, "total_amount")
/// ```
pub fn selectAggregate(self: *Self, agg: AggregateType, field: FieldEnum, alias: []const u8) *Self {
    query.selectAggregate(self, agg, field, alias);
    self.select_raw = true;
    return self;
}

/// Select raw SQL expression
///
/// Example:
/// ```zig
/// .selectRaw("COUNT(*) AS total")
/// ```
pub fn selectRaw(self: *Self, raw_sql: []const u8) *Self {
    query.selectRaw(self, raw_sql);
    self.select_raw = true;
    return self;
}

/// Add a WHERE clause. Multiple calls are ANDed together.
///
/// Example:
/// ```zig
/// .where(.{ .field = .age, .operator = .gt, .value = "$1" })
/// ```
pub fn where(self: *Self, clause: WhereClause) *Self {
    query.where(self, clause);
    return self;
}

/// Add an OR WHERE clause.
///
/// Example:
/// ```zig
/// .orWhere(.{ .field = .age, .operator = .gt, .value = "$1" })
/// ```
pub fn orWhere(self: *Self, clause: WhereClause) *Self {
    query.orWhere(self, clause);
    return self;
}

pub fn buildWhereClauseSql(self: *Self, clause: WhereClause) ![]const u8 {
    return query.buildWhereClauseSql(self, clause, clause.value);
}

/// Add a BETWEEN clause
///
/// Example:
/// ```zig
/// .whereBetween(.age, "$1", "$2")
/// ```
pub fn whereBetween(self: *Self, field: FieldEnum, low: WhereValue, high: WhereValue, valueType: InType) *Self {
    query.whereBetween(self, field, low, high, valueType);
    return self;
}

/// Add a NOT BETWEEN clause
///
/// Example:
/// ```zig
/// .whereNotBetween(.age, "$1", "$2")
/// ```
pub fn whereNotBetween(self: *Self, field: FieldEnum, low: WhereValue, high: WhereValue, valueType: InType) *Self {
    query.whereNotBetween(self, field, low, high, valueType);
    return self;
}

/// Add a WHERE IN clause with values
///
/// Example:
/// ```zig
/// .whereIn(.status, &.{ "'active'", "'pending'" })
/// ```
pub fn whereIn(self: *Self, field: FieldEnum, values: []const []const u8) *Self {
    query.whereIn(self, field, values);
    return self;
}

/// Add a WHERE NOT IN clause with values
///
/// Example:
/// ```zig
/// .whereNotIn(.status, &.{ "'deleted'", "'archived'" })
/// ```
pub fn whereNotIn(self: *Self, field: FieldEnum, values: []const []const u8) *Self {
    query.whereNotIn(self, field, values);
    return self;
}

/// Add a raw WHERE clause
///
/// Example:
/// ```zig
/// .whereRaw("age > $1 AND age < $2")
/// ```
pub fn whereRaw(self: *Self, raw_sql: []const u8) *Self {
    query.whereRaw(self, raw_sql);
    return self;
}

/// Add an OR raw WHERE clause
///
/// Example:
/// ```zig
/// .orWhereRaw("status = 'vip' OR role = 'admin'")
/// ```
pub fn orWhereRaw(self: *Self, raw_sql: []const u8) *Self {
    query.orWhereRaw(self, raw_sql);
    return self;
}

/// Add a WHERE NULL clause
///
/// Example:
/// ```zig
/// .whereNull(.deleted_at)
/// ```
pub fn whereNull(self: *Self, field: FieldEnum) *Self {
    query.whereNull(self, field);
    return self;
}

/// Add a WHERE NOT NULL clause
///
/// Example:
/// ```zig
/// .whereNotNull(.email_verified_at)
/// ```
pub fn whereNotNull(self: *Self, field: FieldEnum) *Self {
    query.whereNotNull(self, field);
    return self;
}

/// Add a WHERE EXISTS subquery
///
/// Example:
/// ```zig
/// .whereExists("SELECT 1 FROM orders WHERE orders.user_id = users.id")
/// ```
pub fn whereExists(self: *Self, subquery: []const u8) *Self {
    query.whereExists(self, subquery);
    return self;
}

/// Add a WHERE NOT EXISTS subquery
///
/// Example:
/// ```zig
/// .whereNotExists("SELECT 1 FROM bans WHERE bans.user_id = users.id")
/// ```
pub fn whereNotExists(self: *Self, subquery: []const u8) *Self {
    query.whereNotExists(self, subquery);
    return self;
}

/// Add a subquery in WHERE clause
///
/// Example:
/// ```zig
/// .whereSubquery(.id, .in, "SELECT user_id FROM premium_users")
/// ```
pub fn whereSubquery(self: *Self, field: FieldEnum, operator: Operator, subquery: []const u8) *Self {
    query.whereSubquery(self, field, operator, subquery);
    return self;
}

pub fn include(self: *Self, rel: IncludeClauseInput) *Self {
    query.include(self, rel);
    return self;
}

/// Add a JOIN clause
///
/// Example:
/// ```zig
/// .join(.inner, "posts", "users.id = posts.user_id")
/// ```
pub fn join(self: *Self, comptime join_clause: JoinClause) *Self {
    query.join(self, join_clause);
    return self;
}


/// Add GROUP BY clause
///
/// Example:
/// ```zig
/// .groupBy(&.{ .status, .role })
/// ```
pub fn groupBy(self: *Self, fields: []const FieldEnum) *Self {
    query.groupBy(self, fields);
    return self;
}

/// Add GROUP BY with raw SQL
///
/// Example:
/// ```zig
/// .groupByRaw("DATE(created_at)")
/// ```
pub fn groupByRaw(self: *Self, raw_sql: []const u8) *Self {
    query.groupByRaw(self, raw_sql);
    return self;
}

/// Add HAVING clause
///
/// Example:
/// ```zig
/// .having("COUNT(*) > $1")
/// ```
pub fn having(self: *Self, condition: []const u8) *Self {
    query.having(self, condition);
    return self;
}

/// Add HAVING with aggregate function
///
/// Example:
/// ```zig
/// .havingAggregate(.count, .id, .gt, "$1")
/// ```
pub fn havingAggregate(self: *Self, agg: AggregateType, field: FieldEnum, operator: Operator, value: []const u8) *Self {
    query.havingAggregate(self, agg, field, operator, value);
    return self;
}

/// Set ORDER BY clause (can be called multiple times)
///
/// Example:
/// ```zig
/// .orderBy(.{ .field = .created_at, .direction = .desc })
/// .orderBy(.{ .field = .name, .direction = .asc })
/// ```
pub fn orderBy(self: *Self, clause: OrderByClause) *Self {
    query.orderBy(self, clause);
    return self;
}

/// Add raw ORDER BY clause
///
/// Example:
/// ```zig
/// .orderByRaw("RANDOM()")
/// ```
pub fn orderByRaw(self: *Self, raw_sql: []const u8) *Self {
    query.orderByRaw(self, raw_sql);
    return self;
}

/// Set LIMIT
///
/// Example:
/// ```zig
/// .limit(10)
/// ```
pub fn limit(self: *Self, n: u64) *Self {
    query.limit(self, n);
    return self;
}

/// Set OFFSET
///
/// Example:
/// ```zig
/// .offset(10)
/// ```
pub fn offset(self: *Self, n: u64) *Self {
    query.offset(self, n);
    return self;
}

/// Paginate results (convenience method for limit + offset)
///
/// Example:
/// ```zig
/// .paginate(2, 20) // Page 2 with 20 items per page
/// ```
pub fn paginate(self: *Self, page: u64, per_page: u64) *Self {
    query.paginate(self, page, per_page);
    return self;
}

/// Include soft-deleted records
pub fn withDeleted(self: *Self) *Self {
    query.withDeleted(self);
    return self;
}

/// Only get soft-deleted records
///
/// Example:
/// ```zig
/// .onlyDeleted()
/// ```
pub fn onlyDeleted(self: *Self) *Self {
    query.onlyDeleted(self);
    return self;
}

// SQL fragment constants for better readability and potential compiler optimization
const SQL_SELECT = "SELECT ";
const SQL_SELECT_DISTINCT = "SELECT DISTINCT ";
const SQL_FROM = " FROM ";
const SQL_WHERE = " WHERE ";
const SQL_AND = " AND ";
const SQL_OR = " OR ";
const SQL_GROUP_BY = " GROUP BY ";
const SQL_HAVING = " HAVING ";
const SQL_ORDER_BY = " ORDER BY ";
const SQL_LIMIT = " LIMIT ";
const SQL_OFFSET = " OFFSET ";
const SQL_COMMA = ", ";
const SQL_WILDCARD_SUFFIX = ".*";
const SQL_WILDCARD_SUFFIX_COMMA = ".*, ";

pub fn buildSql(self: *Self, allocator: std.mem.Allocator) ![]const u8 {
    var sql = std.ArrayList(u8){};
    defer sql.deinit(allocator);

    // Use comptime constant instead of function call
    const table_name = @This().table_name;

    // SELECT clause
    if (self.distinct_enabled) {
        try sql.appendSlice(allocator, SQL_SELECT_DISTINCT);
    } else {
        try sql.appendSlice(allocator, SQL_SELECT);
    }

    var has_select_clause = false;
    if (self.select_clauses.items.len > 0) {
        for (self.select_clauses.items, 0..) |clause, i| {
            try sql.appendSlice(allocator, clause);
            if (i < self.select_clauses.items.len - 1) {
                try sql.appendSlice(allocator, SQL_COMMA);
            }
        }
        has_select_clause = true;
    }

    // build join clause selects
    if (self.join_clauses.items.len > 0) {
        if (has_select_clause) {
            try sql.appendSlice(allocator, SQL_COMMA);
        } else {
            // Use fixed buffer with fallback to allocPrint
            var buf: [256]u8 = undefined;
            const field_str = std.fmt.bufPrint(&buf, "{s}{s}", .{ table_name, SQL_WILDCARD_SUFFIX_COMMA }) catch blk: {
                break :blk try std.fmt.allocPrint(self.arena.allocator(), "{s}{s}", .{ table_name, SQL_WILDCARD_SUFFIX_COMMA });
            };
            try sql.appendSlice(allocator, field_str);
        }
        for (self.join_clauses.items, 0..) |join_clause, j| {
            if (join_clause.select.len == 1 and std.mem.eql(u8, join_clause.select[0], "*")) {
                try sql.writer(allocator).print("jsonb_strip_nulls(to_jsonb({s})) AS {s}", .{
                    @tagName(join_clause.join_table),
                    @tagName(join_clause.join_table),
                });
            } else if (join_clause.select.len == 1 and !std.mem.eql(u8, join_clause.select[0], "*")) {
                self.base_select_custom = true;
                try sql.writer(allocator).print("{s}.{s} AS {s}_{s}", .{
                    @tagName(join_clause.join_table),
                    join_clause.select[0],
                    @tagName(join_clause.join_table),
                    join_clause.select[0],
                });
            } else {
                self.base_select_custom = true;
                for (join_clause.select, 0..) |sel, k| {
                    try sql.writer(allocator).print("{s}.{s} AS {s}_{s}", .{
                        @tagName(join_clause.join_table),
                        sel,
                        @tagName(join_clause.join_table),
                        sel,
                    });
                    if (k < join_clause.select.len - 1) {
                        try sql.appendSlice(allocator, SQL_COMMA);
                    }
                }
            }

            if (j < self.join_clauses.items.len - 1) {
                try sql.appendSlice(allocator, SQL_COMMA);
            }
        }
    } else {
         if (!has_select_clause) {
            // Use comptime base_select when no custom clauses or joins
            // Use fixed buffer with fallback to allocPrint
            var buf: [256]u8 = undefined;
            const field_str = std.fmt.bufPrint(&buf, "{s}{s}", .{ table_name, SQL_WILDCARD_SUFFIX }) catch blk: {
                break :blk try std.fmt.allocPrint(self.arena.allocator(), "{s}{s}", .{ table_name, SQL_WILDCARD_SUFFIX });
            };
            try sql.appendSlice(allocator, field_str);
        }
    }

    // FROM clause - use constant and fixed buffer
    try sql.appendSlice(allocator, SQL_FROM);
    var buf_from: [256]u8 = undefined;
    const from_str = std.fmt.bufPrint(&buf_from, "{s} ", .{table_name}) catch blk: {
        break :blk try std.fmt.allocPrint(self.arena.allocator(), "{s} ", .{table_name});
    };
    try sql.appendSlice(allocator, from_str);

    // Process join clause
    if (self.join_clauses.items.len > 0) {
        for (self.join_clauses.items) |join_clause| {
            try sql.writer(allocator).print("{s} {s} ON {s}.{s} {s} {s}.{s}", .{
                join_clause.join_type.toSql(),
                @tagName(join_clause.join_table),
                @tagName(join_clause.join_field),
                join_clause.join_field.toString(),
                join_clause.join_operator.toSql(),
                @tagName(join_clause.base_field),
                join_clause.base_field.toString(),
            });

            // build predicates
            // LEFT JOIN wallets
            //   ON users.id = wallets.user_id
            //  AND (wallets.wallet_type = 'cash' OR wallets.wallet_type = 'bonus')
            //  AND wallets.is_active = true

            // LEFT JOIN transactions
            //   ON users.id = transactions.user_id
            //  AND (transactions.status = 'completed' OR transactions.status = 'pending')
            //  AND transactions.created_at >= now() - interval '30 days'

            // WHERE users.is_active = true

            // GROUP BY users.id;

            if (join_clause.predicates.len > 0) {
                var in_or_group = false;
                for (join_clause.predicates, 0..) |predicate, i| {
                    const next_is_or = (i < join_clause.predicates.len - 1 and join_clause.predicates[i + 1].where_type == .@"or");

                    if (i == 0) {
                        if (predicate.where_type == .@"or") {
                            return error.FirstPredicateCannotBeOr;
                        }

                        try sql.appendSlice(allocator, SQL_AND);

                        if (next_is_or) {
                            try sql.appendSlice(allocator, "(");
                            in_or_group = true;
                        }

                        try sql.appendSlice(allocator, predicate.sql);
                        continue;
                    }

                    if (predicate.where_type == .@"and") {
                        // Close OR group if we were in one
                        if (in_or_group) {
                            try sql.appendSlice(allocator, ")");
                            in_or_group = false;
                        }

                        try sql.appendSlice(allocator, SQL_AND);

                        // Open OR group if next is OR
                        if (next_is_or) {
                            try sql.appendSlice(allocator, "(");
                            in_or_group = true;
                        }

                        try sql.appendSlice(allocator, predicate.sql);
                    } else { // .@"or"
                        try sql.appendSlice(allocator, SQL_OR);
                        try sql.appendSlice(allocator, predicate.sql);

                        // Close group if next is not OR
                        if (!next_is_or and in_or_group) {
                            try sql.appendSlice(allocator, ")");
                            in_or_group = false;
                        }
                    }
                }

                // Close any remaining OR group
                if (in_or_group) {
                    try sql.appendSlice(allocator, ")");
                }
            }
        }
    }

    var first_where = true;

    // Handle soft deletes
    const has_deleted_at = @hasField(Model, "deleted_at");
    if (has_deleted_at and !self.include_deleted) {
        try sql.appendSlice(allocator, SQL_WHERE);
        try sql.appendSlice(allocator, "deleted_at IS NULL");
        first_where = false;
    }

    // WHERE clauses
    for (self.where_clauses.items) |clause| {
        if (first_where) {
            try sql.appendSlice(allocator, SQL_WHERE);
            first_where = false;
        } else {
            try sql.writer(allocator).print(" {s} ", .{clause.clause_type.toSql()});
        }
        try sql.appendSlice(allocator, clause.sql);
    }

    // GROUP BY clause
    if (self.group_clauses.items.len > 0) {
        try sql.appendSlice(allocator, SQL_GROUP_BY);
        for (self.group_clauses.items, 0..) |group, i| {
            try sql.appendSlice(allocator, group);
            if (i < self.group_clauses.items.len - 1) {
                try sql.appendSlice(allocator, SQL_COMMA);
            }
        }
    }

    // HAVING clause
    if (self.having_clauses.items.len > 0) {
        try sql.appendSlice(allocator, SQL_HAVING);
        for (self.having_clauses.items, 0..) |having_clause, i| {
            try sql.appendSlice(allocator, having_clause);
            if (i < self.having_clauses.items.len - 1) {
                try sql.appendSlice(allocator, SQL_AND);
            }
        }
    }

    // ORDER BY clause
    if (self.order_clauses.items.len > 0) {
        try sql.appendSlice(allocator, SQL_ORDER_BY);
        for (self.order_clauses.items, 0..) |order, i| {
            try sql.appendSlice(allocator, order);
            if (i < self.order_clauses.items.len - 1) {
                try sql.appendSlice(allocator, SQL_COMMA);
            }
        }
    }

    // LIMIT clause
    if (self.limit_val) |l| {
        var buf: [32]u8 = undefined;
        const _limit = try std.fmt.bufPrint(&buf, " LIMIT {d}", .{l});
        try sql.appendSlice(allocator, _limit);
    }

    // OFFSET clause
    if (self.offset_val) |o| {
        var buf: [32]u8 = undefined;
        const _offset = try std.fmt.bufPrint(&buf, " OFFSET {d}", .{o});
        try sql.appendSlice(allocator, _offset);
    }

    return sql.toOwnedSlice(allocator);
}

/// Check if the query has custom projections that can't be mapped to the model type.
/// This includes:
/// - Aggregate functions (COUNT, SUM, etc.)
/// - Raw selects with aliases (AS)
/// - JOIN clauses (result columns from multiple tables)
/// - GROUP BY clauses (typically used with aggregates)
/// - HAVING clauses (requires GROUP BY)
/// - DISTINCT with custom selects
fn hasCustomProjection(self: *Self) bool {
    // Allow include joins/selects; still flag group/having and raw selects
    if (self.group_clauses.items.len > 0 or self.having_clauses.items.len > 0) return true;

    // Treat explicit raw selects as custom
    if (self.select_raw or self.base_select_custom) return true;

    return false;
}

/// Execute query and return list of items.
/// Returns an error if the query contains custom projections that can't map to model type K:
/// - JOINs (use `FieldEnumtchRaw` or `FieldEnumtchAs` with a custom struct)
/// - GROUP BY / HAVING clauses
/// - Aggregate functions (selectAggregate)
/// - Raw selects with aliases or table prefixes
///
/// Example:
/// ```zig
/// const users = try User.query()
///     .where(.{ .field = .status, .operator = .eq, .value = "'active'" })
///     .fetch(&pool, allocator, .{});
/// defer allocator.free(users);
/// ```
pub fn fetch(self: *Self, db: Executor, allocator: std.mem.Allocator, args: anytype) ![]Model {
    if (self.hasCustomProjection()) {
        return error.CustomProjectionNotSupported;
    }

    const temp_allocator = self.arena.allocator();
    const sql = try self.buildSql(temp_allocator);

    var result = try db.queryOpts(sql, args, .{
        .column_names = true,
    });
    defer result.deinit();

    var items = std.ArrayList(Model){};
    defer items.deinit(allocator);

    while (try result.next()) |row| {
        const item = try row.to(Model, .{ .allocator = allocator, .map = .name });
        try items.append(allocator, item);
    }

    return items.toOwnedSlice(allocator);
}


/// Execute query and return list of items mapped to a custom result type.
/// Use this when you have custom selects, aggregates, or need a difFieldEnumrent shape than the model.
///
/// Example:
/// ```zig
/// const UserSummary = struct { id: i64, total_posts: i64 };
/// const summaries = try User.query()
///     .select(&.{.id})
///     .selectAggregate(.count, .id, "total_posts")
///     .groupBy(&.{.id})
///     .fetchAs(UserSummary, &pool, allocator, .{});
/// defer allocator.free(summaries);
/// ```
pub fn fetchAs(self: *Self, comptime R: type, db: Executor, allocator: std.mem.Allocator, args: anytype) ![]R {
    return query.fetchAs(self, R, db, allocator, args);
}

/// Execute query and return the raw pg.Result.
/// Use this for complex queries with joins, subqueries, or when you need full control.
/// The caller is responsible for calling result.deinit() when done.
///
/// Example:
/// ```zig
/// var result = try User.query()
///     .innerJoin("posts", "users.id = posts.user_id")
///     .selectRaw("users.*, posts.title")
///     .fetchRaw(&pool, .{});
/// defer result.deinit();
///
/// while (try result.next()) |row| {
///     const user_id = row.get(i64, 0);
///     const post_title = row.get([]const u8, 1);
///     // ...
/// }
/// ```
pub fn fetchRaw(self: *Self, db: Executor, args: anytype) !pg.Result {
    return query.fetchRaw(self, db, args);
}

/// Fetch results using a relation type's fromRow() method for JSONB parsing.
/// Use this when you have included relations that return JSONB columns.
///
/// The type R must have a `fromRow(row, allocator) !R` method (like types from rel.zig).
///
/// Example:
/// ```zig
/// const UsersWithPosts = Users.Rel.UsersWithPosts;
/// const results = try User.query()
///     .include(.{ .posts = .{} })
///     .fetchWithRel(UsersWithPosts, &pool, allocator, .{});
/// // results[0].posts is now parsed from JSONB!
/// ```
pub fn fetchWithRel(self: *Self, comptime R: type, db: Executor, allocator: std.mem.Allocator, args: anytype) ![]R {
     comptime {
        if (!std.mem.eql(u8, R.fromRow, undefined)) {
            @compileError("R must have fromRow method");
        }
    }
    return query.fetchWithRel(self, R, db, allocator, args);
}

/// Execute query and return first item or null.
/// Returns an error if the query contains custom projections (JOINs, GROUP BY, aggregates, etc.).
/// Use `firstAs` for custom result types or `firstRaw` for direct access.
pub fn first(self: *Self, db: Executor, allocator: std.mem.Allocator, args: anytype) !?Model {
    if (self.hasCustomProjection()) {
        return error.CustomProjectionNotSupported;
    }

    self.fill_base_select = true; // ensure base selects are included

    self.limit_val = 1;
    const temp_allocator = self.arena.allocator();
    const sql = try self.buildSql(temp_allocator);

    var result = try db.queryOpts(sql, args, .{
        .column_names = true,
    });
    defer result.deinit();

    if (try result.next()) |row| {
        const item = try row.to(Model, .{ .allocator = allocator, .map = .name });
        return item;
    }
    return null;
}

/// Execute query and return first item mapped to a custom result type, or null.
///
/// Example:
/// ```zig
/// const UserStats = struct { id: i64, post_count: i64 };
/// const stats = try User.query()
///     .select(&.{.id})
///     .selectAggregate(.count, .id, "post_count")
///     .where(.{ .field = .id, .operator = .eq, .value = "$1" })
///     .firstAs(UserStats, &pool, allocator, .{user_id});
/// ```
pub fn firstAs(self: *Self, comptime R: type, db: Executor, allocator: std.mem.Allocator, args: anytype) !?R {
    return query.firstAs(self, R, db, allocator, args);
}

/// Fetch first result using a relation type's fromRow() method for JSONB parsing.
/// Use this when you have included relations that return JSONB columns.
///
/// The type R must have a `fromRow(row, allocator) !R` method (like types from rel.zig).
///
/// Example:
/// ```zig
/// const UsersWithPosts = Users.Rel.UsersWithPosts;
/// const user = try User.query()
///     .include(.{ .posts = .{} })
///     .where(.{ .field = .id, .operator = .eq, .value = .{ .string = id }})
///     .firstWithRel(UsersWithPosts, &pool, allocator, .{});
/// // user.?.posts is now parsed from JSONB!
/// ```
pub fn firstWithRel(self: *Self, comptime R: type, db: Executor, allocator: std.mem.Allocator, args: anytype) !?R {
     comptime {
        if (!std.mem.eql(u8, R.fromRow, undefined)) {
            @compileError("R must have fromRow method");
        }
    }
    return query.firstWithRel(self, R, db, allocator, args);
}

/// Execute query and return first row as pg.QueryRow or null.
/// The caller is responsible for calling row.deinit() when done.
///
/// Example:
/// ```zig
/// if (try User.query()
///     .selectRaw("users.*, COUNT(posts.id) as post_count")
///     .innerJoin("posts", "users.id = posts.user_id")
///     .firstRaw(&pool, .{})) |row|
/// {
///     defer row.deinit();
///     const name = row.get([]const u8, 1);
///     const post_count = row.get(i64, 2);
/// }
/// ```
pub fn firstRaw(self: *Self, db: Executor, args: anytype) !?pg.Result {
    return query.firstRaw(self, db, args);
}

/// Delete a record
pub fn delete(self: *Self, db: Executor, args: anytype) !void {
    return query.delete(self, db, args, Model);
}

/// Count records matching the query
pub fn count(self: *Self, db: Executor, args: anytype) !i64 {
    return query.count(self, db, args, Model);
}

/// Check if any records match the query
///
/// Example:
/// ```zig
/// const has_users = try User.query()
///     .where(.{ .field = .status, .operator = .eq, .value = "'active'" })
///     .exists(&pool);
/// ```
pub fn exists(self: *Self, db: Executor, args: anytype) !bool {
    return query.exists(self, db, args, Model);
}

/// Get a single column as a slice
/// !NOT working for non string field
///
/// Example:
/// ```zig
/// const emails = try User.query().pluck(&pool, allocator, .email, .{});
/// ```
pub fn pluck(self: *Self, db: Executor, allocator: std.mem.Allocator, field: FieldEnum, args: anytype) ![][]const u8 {
    return query.pluck(self, db, allocator, field, args, Model);
}

/// Get the sum of a column
///
/// Example:
/// ```zig
/// const total = try Order.query().sum(&pool, .amount, .{});
/// ```
pub fn sum(self: *Self, db: Executor, field: FieldEnum, args: anytype) !f64 {
    return self.aggregate(db, .sum, field, args);
}

/// Get the average of a column
///
/// Example:
/// ```zig
/// const avg_rating = try Review.query().avg(&pool, .rating, .{});
/// ```
pub fn avg(self: *Self, db: Executor, field: FieldEnum, args: anytype) !f64 {
    return self.aggregate(db, .avg, field, args);
}

/// Get the minimum value of a column
///
/// Example:
/// ```zig
/// const min_price = try Product.query().min(&pool, .price, .{});
/// ```
pub fn min(self: *Self, db: Executor, field: FieldEnum, args: anytype) !f64 {
    return self.aggregate(db, .min, field, args);
}

/// Get the maximum value of a column
///
/// Example:
/// ```zig
/// const max_price = try Product.query().max(&pool, .price, .{});
/// ```
pub fn max(self: *Self, db: Executor, field: FieldEnum, args: anytype) !f64 {
    return self.aggregate(db, .max, field, args);
}

fn aggregate(self: *Self, db: Executor, agg: AggregateType, field: FieldEnum, args: anytype) !f64 {
    return query.aggregate(self, db, agg, field, args, Model);
}

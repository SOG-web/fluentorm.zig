// AUTO-GENERATED CODE - DO NOT EDIT
// Generated by scripts/generate_model.zig
// Source schema: organizations.zig
// To regenerate: zig run scripts/generate_model.zig -- organizations.zig

const std = @import("std");
const pg = @import("pg");
const BaseModel = @import("../base.zig").BaseModel;
const Query = @import("query.zig");
const Relationship = @import("../base.zig").Relationship;
const Tables = @import("../registry.zig").Tables;
const Executor = @import("../executor.zig").Executor;
const err = @import("../error.zig");
const OrmError = err.OrmError;

// Related models
const OrganizationUsers = @import("../organization_users/model.zig");
const OrganizationUsersQuery = @import("../organization_users/query.zig");

const Organizations = @This();

// Fields
    id: []const u8,
    name: []const u8,
    email: []const u8,
    phone: []const u8,
    address: []const u8,
    website: []const u8,
    industry: []const u8,
    business_registration_number: ?[]const u8,
    tax_id: ?[]const u8,
    verification_status: ?[]const u8,
    verification_documents: ?[]const u8,
    required_documents: ?[]const u8,
    uploaded_documents: ?[]const u8,
    onboarding_status: ?[]const u8,
    subscription_plan: []const u8,
    billing_email: ?[]const u8,
    status: []const u8,
    created_at: i64,
    updated_at: i64,
    deleted_at: ?i64,
    pub const FieldEnum = enum {
        id,
        name,
        email,
        phone,
        address,
        website,
        industry,
        business_registration_number,
        tax_id,
        verification_status,
        verification_documents,
        required_documents,
        uploaded_documents,
        onboarding_status,
        subscription_plan,
        billing_email,
        status,
        created_at,
        updated_at,
        deleted_at,

        pub fn isDateTime(self: @This()) bool {
            return switch (self) {
                .created_at => true,
                .updated_at => true,
                .deleted_at => true,
                else => false,
            };
        }
    };
    pub const RelationEnum = enum {
        users,
    };

    pub fn getRelation(rel: RelationEnum) Relationship {
        return switch (rel) {
            .users => .{ .name = "users", .type = .hasMany, .foreign_table = .organization_users, .foreign_key = .{ .organization_users = .organization_id }, .local_key = .{ .organizations = .id } },
        };
    }

    pub const OrganizationUsersIncludeClauseInput = struct {
        model_name: RelationEnum,
        select: []const OrganizationUsers.FieldEnum = &.{},
        where: []const OrganizationUsersQuery.WhereClause = &.{},
    };

    pub const IncludeClauseInput = union(RelationEnum) {
        users: OrganizationUsersIncludeClauseInput,
    };

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        allocator.free(self.id);
        allocator.free(self.name);
        allocator.free(self.email);
        allocator.free(self.phone);
        allocator.free(self.address);
        allocator.free(self.website);
        allocator.free(self.industry);
        if (self.business_registration_number) |v| allocator.free(v);
        if (self.tax_id) |v| allocator.free(v);
        if (self.verification_status) |v| allocator.free(v);
        if (self.verification_documents) |v| allocator.free(v);
        if (self.required_documents) |v| allocator.free(v);
        if (self.uploaded_documents) |v| allocator.free(v);
        if (self.onboarding_status) |v| allocator.free(v);
        allocator.free(self.subscription_plan);
        if (self.billing_email) |v| allocator.free(v);
        allocator.free(self.status);
    }

    // Input type for creating new records
    pub const CreateInput = struct {
        name: []const u8,
        email: []const u8,
        phone: []const u8,
        address: []const u8,
        website: []const u8,
        industry: []const u8,
        business_registration_number: ?[]const u8 = null,
        tax_id: ?[]const u8 = null,
        verification_status: ?[]const u8 = null,
        verification_documents: ?[]const u8 = null,
        required_documents: ?[]const u8 = null,
        uploaded_documents: ?[]const u8 = null,
        onboarding_status: ?[]const u8 = null,
        subscription_plan: ?[]const u8 = null,
        billing_email: ?[]const u8 = null,
        status: ?[]const u8 = null,
    };

    // Input type for updating existing records
    pub const UpdateInput = struct {
        name: ?[]const u8 = null,
        email: ?[]const u8 = null,
        phone: ?[]const u8 = null,
        address: ?[]const u8 = null,
        website: ?[]const u8 = null,
        industry: ?[]const u8 = null,
        business_registration_number: ?[]const u8 = null,
        tax_id: ?[]const u8 = null,
        verification_status: ?[]const u8 = null,
        verification_documents: ?[]const u8 = null,
        required_documents: ?[]const u8 = null,
        uploaded_documents: ?[]const u8 = null,
        onboarding_status: ?[]const u8 = null,
        subscription_plan: ?[]const u8 = null,
        billing_email: ?[]const u8 = null,
        status: ?[]const u8 = null,
    };

    // Model configuration
    pub fn tableName() []const u8 {
        return "organizations";
    }

    pub const json_all_fields_sql = "jsonb_build_object('id', id, 'name', name, 'email', email, 'phone', phone, 'address', address, 'website', website, 'industry', industry, 'business_registration_number', business_registration_number, 'tax_id', tax_id, 'verification_status', verification_status, 'verification_documents', verification_documents, 'required_documents', required_documents, 'uploaded_documents', uploaded_documents, 'onboarding_status', onboarding_status, 'subscription_plan', subscription_plan, 'billing_email', billing_email, 'status', status, 'created_at', (extract(epoch from created_at) * 1000000)::bigint, 'updated_at', (extract(epoch from updated_at) * 1000000)::bigint, 'deleted_at', (extract(epoch from deleted_at) * 1000000)::bigint)";

    pub fn insertSQL() []const u8 {
        return
            \\INSERT INTO organizations (
            \\    name, email, phone, address, website, industry, business_registration_number, tax_id, verification_status, verification_documents, required_documents, uploaded_documents, onboarding_status, subscription_plan, billing_email, status
            \\) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, COALESCE($13, 'pending_approval'), COALESCE($14, 'basic'), $15, COALESCE($16, 'active'))
            \\RETURNING id
        ;
    }

    pub fn insertParams(data: CreateInput) struct {
        []const u8,
        []const u8,
        []const u8,
        []const u8,
        []const u8,
        []const u8,
        ?[]const u8,
        ?[]const u8,
        ?[]const u8,
        ?[]const u8,
        ?[]const u8,
        ?[]const u8,
        ?[]const u8,
        ?[]const u8,
        ?[]const u8,
        ?[]const u8,
    } {
        return .{
            data.name,
            data.email,
            data.phone,
            data.address,
            data.website,
            data.industry,
            data.business_registration_number,
            data.tax_id,
            data.verification_status,
            data.verification_documents,
            data.required_documents,
            data.uploaded_documents,
            data.onboarding_status,
            data.subscription_plan,
            data.billing_email,
            data.status,
        };
    }

    pub fn updateSQL() []const u8 {
        return
            \\UPDATE organizations SET
            \\    name = COALESCE($2, name),
            \\    email = COALESCE($3, email),
            \\    phone = COALESCE($4, phone),
            \\    address = COALESCE($5, address),
            \\    website = COALESCE($6, website),
            \\    industry = COALESCE($7, industry),
            \\    business_registration_number = COALESCE($8, business_registration_number),
            \\    tax_id = COALESCE($9, tax_id),
            \\    verification_status = COALESCE($10, verification_status),
            \\    verification_documents = COALESCE($11, verification_documents),
            \\    required_documents = COALESCE($12, required_documents),
            \\    uploaded_documents = COALESCE($13, uploaded_documents),
            \\    onboarding_status = COALESCE($14, onboarding_status),
            \\    subscription_plan = COALESCE($15, subscription_plan),
            \\    billing_email = COALESCE($16, billing_email),
            \\    status = COALESCE($17, status),
            \\    updated_at =  CURRENT_TIMESTAMP
            \\WHERE id = $1
        ;
    }

    pub fn updateParams(id: []const u8, data: UpdateInput) struct {
        []const u8,
        ?[]const u8,
        ?[]const u8,
        ?[]const u8,
        ?[]const u8,
        ?[]const u8,
        ?[]const u8,
        ?[]const u8,
        ?[]const u8,
        ?[]const u8,
        ?[]const u8,
        ?[]const u8,
        ?[]const u8,
        ?[]const u8,
        ?[]const u8,
        ?[]const u8,
        ?[]const u8,
    } {
        return .{
            id,
            data.name,
            data.email,
            data.phone,
            data.address,
            data.website,
            data.industry,
            data.business_registration_number,
            data.tax_id,
            data.verification_status,
            data.verification_documents,
            data.required_documents,
            data.uploaded_documents,
            data.onboarding_status,
            data.subscription_plan,
            data.billing_email,
            data.status,
        };
    }

    pub fn upsertSQL() []const u8 {
        return
            \\INSERT INTO organizations (
            \\    name, email, phone, address, website, industry, business_registration_number, tax_id, verification_status, verification_documents, required_documents, uploaded_documents, onboarding_status, subscription_plan, billing_email, status
            \\) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16)
            \\ON CONFLICT (name) DO UPDATE SET
            \\    address = EXCLUDED.address,
            \\    industry = EXCLUDED.industry,
            \\    verification_status = EXCLUDED.verification_status,
            \\    verification_documents = EXCLUDED.verification_documents,
            \\    required_documents = EXCLUDED.required_documents,
            \\    uploaded_documents = EXCLUDED.uploaded_documents,
            \\    onboarding_status = EXCLUDED.onboarding_status,
            \\    subscription_plan = EXCLUDED.subscription_plan,
            \\    billing_email = EXCLUDED.billing_email,
            \\    status = EXCLUDED.status
            \\RETURNING id
        ;
    }

    pub fn upsertParams(data: CreateInput) struct {
        []const u8,
        []const u8,
        []const u8,
        []const u8,
        []const u8,
        []const u8,
        ?[]const u8,
        ?[]const u8,
        ?[]const u8,
        ?[]const u8,
        ?[]const u8,
        ?[]const u8,
        ?[]const u8,
        ?[]const u8,
        ?[]const u8,
        ?[]const u8,
    } {
        return .{
            data.name,
            data.email,
            data.phone,
            data.address,
            data.website,
            data.industry,
            data.business_registration_number,
            data.tax_id,
            data.verification_status,
            data.verification_documents,
            data.required_documents,
            data.uploaded_documents,
            data.onboarding_status,
            data.subscription_plan,
            data.billing_email,
            data.status,
        };
    }

    const base = BaseModel(Organizations);
    // DDL operations

    pub const truncate = base.truncate;

    pub const tableExists = base.tableExists;

    // CRUD operations
    pub const findById = base.findById;

    pub const findAll = base.findAll;

    pub const insert = base.insert;

    pub const insertMany = base.insertMany;

    pub const insertAndReturn = base.insertAndReturn;

    pub const update = base.update;

    pub const updateAndReturn = base.updateAndReturn;

    pub const upsert = base.upsert;

    pub const upsertAndReturn = base.upsertAndReturn;

    pub const softDelete = base.softDelete;

    pub const hardDelete = base.hardDelete;

    pub const count = base.count;

    pub const fromRow = base.fromRow;

    pub const query = Query.init;

    pub const queryWithArena = Query.initWithArena;

    pub const queryWithAllocator = Query.initWithAllocator;


    /// JSON-safe response struct with UUIDs as hex strings
    pub const JsonResponse = struct {
        id: [36]u8,
        name: []const u8,
        email: []const u8,
        phone: []const u8,
        address: []const u8,
        website: []const u8,
        industry: []const u8,
        business_registration_number: ?[]const u8,
        tax_id: ?[]const u8,
        verification_status: ?[]const u8,
        verification_documents: ?[]const u8,
        required_documents: ?[]const u8,
        uploaded_documents: ?[]const u8,
        onboarding_status: ?[]const u8,
        subscription_plan: []const u8,
        billing_email: ?[]const u8,
        status: []const u8,
        created_at: i64,
        updated_at: i64,
        deleted_at: ?i64,
    };

    /// Convert model to JSON-safe response with UUIDs as hex strings
    pub fn toJsonResponse(self: Organizations) !JsonResponse {
        return JsonResponse{
            .id = try pg.uuidToHex(&self.id[0..16].*),
            .name = self.name,
            .email = self.email,
            .phone = self.phone,
            .address = self.address,
            .website = self.website,
            .industry = self.industry,
            .business_registration_number = self.business_registration_number,
            .tax_id = self.tax_id,
            .verification_status = self.verification_status,
            .verification_documents = self.verification_documents,
            .required_documents = self.required_documents,
            .uploaded_documents = self.uploaded_documents,
            .onboarding_status = self.onboarding_status,
            .subscription_plan = self.subscription_plan,
            .billing_email = self.billing_email,
            .status = self.status,
            .created_at = self.created_at,
            .updated_at = self.updated_at,
            .deleted_at = self.deleted_at,
        };
    }

    /// JSON-safe response struct with UUIDs as hex strings (excludes redacted fields)
    pub const JsonResponseSafe = struct {
        id: [36]u8,
        name: []const u8,
        email: []const u8,
        phone: []const u8,
        address: []const u8,
        website: []const u8,
        industry: []const u8,
        business_registration_number: ?[]const u8,
        tax_id: ?[]const u8,
        verification_status: ?[]const u8,
        verification_documents: ?[]const u8,
        required_documents: ?[]const u8,
        uploaded_documents: ?[]const u8,
        onboarding_status: ?[]const u8,
        subscription_plan: []const u8,
        billing_email: ?[]const u8,
        status: []const u8,
        created_at: i64,
        updated_at: i64,
        deleted_at: ?i64,
    };

    /// Convert model to JSON-safe response excluding redacted fields (passwords, tokens, etc.)
    pub fn toJsonResponseSafe(self: Organizations) !JsonResponseSafe {
        return JsonResponseSafe{
            .id = try pg.uuidToHex(&self.id[0..16].*),
            .name = self.name,
            .email = self.email,
            .phone = self.phone,
            .address = self.address,
            .website = self.website,
            .industry = self.industry,
            .business_registration_number = self.business_registration_number,
            .tax_id = self.tax_id,
            .verification_status = self.verification_status,
            .verification_documents = self.verification_documents,
            .required_documents = self.required_documents,
            .uploaded_documents = self.uploaded_documents,
            .onboarding_status = self.onboarding_status,
            .subscription_plan = self.subscription_plan,
            .billing_email = self.billing_email,
            .status = self.status,
            .created_at = self.created_at,
            .updated_at = self.updated_at,
            .deleted_at = self.deleted_at,
        };
    }
    // Relationship methods
    /// Fetch all related OrganizationUsers records for this Organizations (one-to-many)
    pub fn fetchUsers(self: *const Organizations, db: Executor, allocator: std.mem.Allocator) err.Result([]OrganizationUsers) {
        const queryt = "SELECT * FROM organization_users WHERE organization_id = $1";
        const res = db.queryWithErr(queryt, .{self.id});
        switch (res) {
            .err => |e| return .{ .err = e },
            .ok => |*result| {
                defer result.deinit();
                var list = std.ArrayList(OrganizationUsers){};
                while (result.next() catch |e| {
                    list.deinit(allocator);
                    return .{ .err = OrmError.fromError(e) };
                }) |row| {
                    const item = row.to(OrganizationUsers, .{ .allocator = allocator, .map = .ordinal }) catch |e| {
                        list.deinit(allocator);
                        return .{ .err = OrmError.fromError(e) };
                    };
                    list.append(allocator, item) catch |e| {
                        list.deinit(allocator);
                        return .{ .err = OrmError.fromError(e) };
                    };
                }
                const slice = list.toOwnedSlice(allocator) catch |e| {
                    return .{ .err = OrmError.fromError(e) };
                };
                return .{ .ok = slice };
            },
        }
    }


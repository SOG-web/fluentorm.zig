// AUTO-GENERATED CODE - DO NOT EDIT
// Generated by scripts/generate_model.zig
// Source schema: users.zig
// To regenerate: zig run scripts/generate_model.zig -- users.zig

const std = @import("std");
const pg = @import("pg");
const BaseModel = @import("base.zig").BaseModel;
const Executor = @import("executor.zig").Executor;
const includeQuery = @import("includeQuery.zig");
const QueryBuilder = @import("query.zig").QueryBuilder;
const Transaction = @import("transaction.zig").Transaction;

// Related models
const Comments = @import("comments.zig");
const Posts = @import("posts.zig");

const Users = @This();

// Fields
id: []const u8,
email: []const u8,
name: []const u8,
bid: ?[]const u8,
password_hash: []const u8,
is_active: bool,
created_at: i64,
updated_at: i64,
deleted_at: ?i64,
phone: ?[]const u8,
bio: ?[]const u8,
    pub const FieldEnum = enum {
        id,
        email,
        name,
        bid,
        password_hash,
        is_active,
        created_at,
        updated_at,
        deleted_at,
        phone,
        bio,
    };


    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        allocator.free(self.id);
        allocator.free(self.email);
        allocator.free(self.name);
        if (self.bid) |v| allocator.free(v);
        allocator.free(self.password_hash);
        if (self.phone) |v| allocator.free(v);
        if (self.bio) |v| allocator.free(v);
    }

    // Input type for creating new records
    pub const CreateInput = struct {
        email: []const u8,
        name: []const u8,
        bid: ?[]const u8,
        password_hash: []const u8,
        is_active: ?bool = null,
        phone: ?[]const u8 = null,
        bio: ?[]const u8 = null,
    };

    // Input type for updating existing records
    pub const UpdateInput = struct {
        email: ?[]const u8 = null,
        name: ?[]const u8 = null,
        bid: ?[]const u8 = null,
        password_hash: ?[]const u8 = null,
        is_active: ?bool = null,
        phone: ?[]const u8 = null,
        bio: ?[]const u8 = null,
    };

    // Model configuration
    pub fn tableName() []const u8 {
        return "users";
    }

    pub fn insertSQL() []const u8 {
        return
            \\INSERT INTO users (
            \\    email, name, bid, password_hash, is_active, phone, bio
            \\) VALUES ($1, $2, $3, $4, COALESCE($5, 'true'), $6, $7)
            \\RETURNING id
        ;
    }

    pub fn insertParams(data: CreateInput) struct {
        []const u8,
        []const u8,
        ?[]const u8,
        []const u8,
        ?bool,
        ?[]const u8,
        ?[]const u8,
    } {
        return .{
            data.email,
            data.name,
            data.bid,
            data.password_hash,
            data.is_active,
            data.phone,
            data.bio,
        };
    }

    pub fn updateSQL() []const u8 {
        return
            \\UPDATE users SET
            \\    email = COALESCE($2, email),
            \\    name = COALESCE($3, name),
            \\    bid = COALESCE($4, bid),
            \\    password_hash = COALESCE($5, password_hash),
            \\    is_active = COALESCE($6, is_active),
            \\    updated_at =  CURRENT_TIMESTAMP,
            \\    phone = COALESCE($7, phone),
            \\    bio = COALESCE($8, bio)
            \\WHERE id = $1
        ;
    }

    pub fn updateParams(id: []const u8, data: UpdateInput) struct {
        []const u8,
        ?[]const u8,
        ?[]const u8,
        ?[]const u8,
        ?[]const u8,
        ?bool,
        ?[]const u8,
        ?[]const u8,
    } {
        return .{
            id,
            data.email,
            data.name,
            data.bid,
            data.password_hash,
            data.is_active,
            data.phone,
            data.bio,
        };
    }

    pub fn upsertSQL() []const u8 {
        return
            \\INSERT INTO users (
            \\    email, name, bid, password_hash, is_active, phone, bio
            \\) VALUES ($1, $2, $3, $4, $5, $6, $7)
            \\ON CONFLICT (email) DO UPDATE SET
            \\    name = EXCLUDED.name,
            \\    bid = EXCLUDED.bid,
            \\    password_hash = EXCLUDED.password_hash,
            \\    is_active = EXCLUDED.is_active,
            \\    phone = EXCLUDED.phone,
            \\    bio = EXCLUDED.bio
            \\RETURNING id
        ;
    }

    pub fn upsertParams(data: CreateInput) struct {
        []const u8,
        []const u8,
        ?[]const u8,
        []const u8,
        ?bool,
        ?[]const u8,
        ?[]const u8,
    } {
        return .{
            data.email,
            data.name,
            data.bid,
            data.password_hash,
            data.is_active,
            data.phone,
            data.bio,
        };
    }

    const base = BaseModel(Users);
    // DDL operations

    pub const truncate = base.truncate;

    pub const tableExists = base.tableExists;

    // CRUD operations
    pub const findById = base.findById;

    pub const findAll = base.findAll;

    pub const insert = base.insert;

    pub const insertMany = base.insertMany;

    pub const insertAndReturn = base.insertAndReturn;

    pub const update = base.update;

    pub const updateAndReturn = base.updateAndReturn;

    pub const upsert = base.upsert;

    pub const upsertAndReturn = base.upsertAndReturn;

    pub const softDelete = base.softDelete;

    pub const hardDelete = base.hardDelete;

    pub const count = base.count;

    pub const fromRow = base.fromRow;

    pub fn query() QueryBuilder(Users, UpdateInput, FieldEnum) {
        return QueryBuilder(Users, UpdateInput, FieldEnum).init();
    }


    /// JSON-safe response struct with UUIDs as hex strings
    pub const JsonResponse = struct {
        id: [36]u8,
        email: []const u8,
        name: []const u8,
        bid: ?[]const u8,
        password_hash: []const u8,
        is_active: bool,
        created_at: i64,
        updated_at: i64,
        deleted_at: ?i64,
        phone: ?[]const u8,
        bio: ?[]const u8,
    };

    /// Convert model to JSON-safe response with UUIDs as hex strings
    pub fn toJsonResponse(self: Users) !JsonResponse {
        return JsonResponse{
            .id = try pg.uuidToHex(&self.id[0..16].*),
            .email = self.email,
            .name = self.name,
            .bid = self.bid,
            .password_hash = self.password_hash,
            .is_active = self.is_active,
            .created_at = self.created_at,
            .updated_at = self.updated_at,
            .deleted_at = self.deleted_at,
            .phone = self.phone,
            .bio = self.bio,
        };
    }

    /// JSON-safe response struct with UUIDs as hex strings (excludes redacted fields)
    pub const JsonResponseSafe = struct {
        id: [36]u8,
        email: []const u8,
        name: []const u8,
        bid: ?[]const u8,
        is_active: bool,
        created_at: i64,
        updated_at: i64,
        deleted_at: ?i64,
        phone: ?[]const u8,
        bio: ?[]const u8,
    };

    /// Convert model to JSON-safe response excluding redacted fields (passwords, tokens, etc.)
    pub fn toJsonResponseSafe(self: Users) !JsonResponseSafe {
        return JsonResponseSafe{
            .id = try pg.uuidToHex(&self.id[0..16].*),
            .email = self.email,
            .name = self.name,
            .bid = self.bid,
            .is_active = self.is_active,
            .created_at = self.created_at,
            .updated_at = self.updated_at,
            .deleted_at = self.deleted_at,
            .phone = self.phone,
            .bio = self.bio,
        };
    }
    // Relationship methods
    /// Fetch all related Posts records for this Users (one-to-many)
    pub fn fetchPosts(self: *const Users, db: *pg.Pool, allocator: std.mem.Allocator) ![]Posts {
        const queryt = "SELECT * FROM posts WHERE user_id = $1";
        var result = try db.query(queryt, .{self.id});
        defer result.deinit();

        var list = std.ArrayList(Posts){};
        errdefer list.deinit(allocator);

        while (try result.next()) |row| {
            const item = try row.to(Posts, .{ .allocator = allocator, .map = .ordinal });
            try list.append(allocator, item);
        }

        return try list.toOwnedSlice(allocator);
    }

    /// Fetch all related Comments records for this Users (one-to-many)
    pub fn fetchComments(self: *const Users, db: *pg.Pool, allocator: std.mem.Allocator) ![]Comments {
        const queryt = "SELECT * FROM comments WHERE user_id = $1";
        var result = try db.query(queryt, .{self.id});
        defer result.deinit();

        var list = std.ArrayList(Comments){};
        errdefer list.deinit(allocator);

        while (try result.next()) |row| {
            const item = try row.to(Comments, .{ .allocator = allocator, .map = .ordinal });
            try list.append(allocator, item);
        }

        return try list.toOwnedSlice(allocator);
    }


    // Relationship metadata for include queries
    pub const rel_posts = includeQuery.RelationMeta{
        .name = "posts",
        .table = "posts",
        .foreign_key = "user_id",
        .local_key = "id",
        .relation_type = .has_many,
    };
    pub const rel_comments = includeQuery.RelationMeta{
        .name = "comments",
        .table = "comments",
        .foreign_key = "user_id",
        .local_key = "id",
        .relation_type = .has_many,
    };

    /// Query Users with Posts included (eager loading)
    pub fn includePosts(db: Executor, allocator: std.mem.Allocator, where_clause: ?[]const u8, args: anytype) ![]includeQuery.WithRelation(Users, Posts, "posts") {
        return includeQuery.executeIncludeQuery(
            Users,
            Posts,
            rel_posts,
            db,
            allocator,
            where_clause,
            args,
        );
    }

    /// Query Users with Comments included (eager loading)
    pub fn includeComments(db: Executor, allocator: std.mem.Allocator, where_clause: ?[]const u8, args: anytype) ![]includeQuery.WithRelation(Users, Comments, "comments") {
        return includeQuery.executeIncludeQuery(
            Users,
            Comments,
            rel_comments,
            db,
            allocator,
            where_clause,
            args,
        );
    }
    // Transaction support (use generic Transaction from transaction.zig)
    // Example:
    //   var tx = try Transaction.begin(pool);
    //   defer tx.deinit();
    //   const id = try @This().insert(tx.executor(), allocator, data);
    //   try tx.commit();
